<!DOCTYPE html>
<html lang="zh-CN" dir="ltr">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>面试官：只知道v-model是modelValue语法糖，那你可以走了 | 想躺不敢躺</title>
    <meta name="description" content="啥都不会，只想躺平，看看小说，听听音乐，晒晒太阳">
    <meta name="generator" content="VitePress v1.2.3">
    <link rel="preload stylesheet" href="/jiang225638.github.io/assets/style.Cj6Y3KPo.css" as="style">
    
    <script type="module" src="/jiang225638.github.io/assets/app.DwYD_Nav.js"></script>
    <link rel="preload" href="/jiang225638.github.io/assets/inter-roman-latin.Di8DUHzh.woff2" as="font" type="font/woff2" crossorigin="">
    <link rel="modulepreload" href="/jiang225638.github.io/assets/chunks/framework.DaHLRe2H.js">
    <link rel="modulepreload" href="/jiang225638.github.io/assets/chunks/theme.BRMf-PcQ.js">
    <link rel="modulepreload" href="/jiang225638.github.io/assets/excellentArticle_2024-04-18_index.md.al8Mrv1-.lean.js">
    <meta name="theme-color" content="#3eaf7c">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <link rel="apple-touch-icon" href="/favicon.ico">
    <link rel="mask-icon" href="/favicon.ico" color="#3eaf7c">
    <meta name="msapplication-TileImage" content="/favicon.ico">
    <meta name="msapplication-TileColor" content="#000000">
    <script id="check-dark-mode">(()=>{const e=localStorage.getItem("vitepress-theme-appearance")||"auto",a=window.matchMedia("(prefers-color-scheme: dark)").matches;(!e||e==="auto"?a:e==="dark")&&document.documentElement.classList.add("dark")})();</script>
    <script id="check-mac-os">document.documentElement.classList.toggle("mac",/Mac|iPhone|iPod|iPad/i.test(navigator.platform));</script>
  </head>
  <body>
    <div id="app"><div class="Layout" data-v-113dd8ef><!--[--><!--]--><!--[--><span tabindex="-1" data-v-0a1adbd1></span><a href="#VPContent" class="VPSkipLink visually-hidden" data-v-0a1adbd1> Skip to content </a><!--]--><!----><header class="VPNav" data-v-113dd8ef data-v-cd13f00d><div class="VPNavBar has-sidebar top" data-v-cd13f00d data-v-8b5c946b><div class="wrapper" data-v-8b5c946b><div class="container" data-v-8b5c946b><div class="title" data-v-8b5c946b><div class="VPNavBarTitle has-sidebar" data-v-8b5c946b data-v-299cbcbe><a class="title" href="/jiang225638.github.io/" data-v-299cbcbe><!--[--><!--]--><!--[--><img class="VPImage logo" src="/jiang225638.github.io/logo1.gif" alt data-v-11e0b147><!--]--><span data-v-299cbcbe>想躺不敢躺</span><!--[--><!--]--></a></div></div><div class="content" data-v-8b5c946b><div class="content-body" data-v-8b5c946b><!--[--><!--]--><div class="VPNavBarSearch search" data-v-8b5c946b><!----></div><nav aria-labelledby="main-nav-aria-label" class="VPNavBarMenu menu" data-v-8b5c946b data-v-f8d8594d><span id="main-nav-aria-label" class="visually-hidden" data-v-f8d8594d>Main Navigation</span><!--[--><!--[--><div class="VPFlyout VPNavBarMenuGroup" data-v-f8d8594d data-v-a89f3eba><button type="button" class="button" aria-haspopup="true" aria-expanded="false" data-v-a89f3eba><span class="text" data-v-a89f3eba><!----><span data-v-a89f3eba>看穿尘世</span><span class="vpi-chevron-down text-icon" data-v-a89f3eba></span></span></button><div class="menu" data-v-a89f3eba><div class="VPMenu" data-v-a89f3eba data-v-515abb69><div class="items" data-v-515abb69><!--[--><!--[--><div class="VPMenuLink" data-v-515abb69 data-v-3a51b523><a class="VPLink link" href="/jiang225638.github.io/js/" data-v-3a51b523><!--[-->js<!--]--></a></div><!--]--><!--[--><div class="VPMenuLink" data-v-515abb69 data-v-3a51b523><a class="VPLink link" href="/jiang225638.github.io/ts/" data-v-3a51b523><!--[-->TS<!--]--></a></div><!--]--><!--[--><div class="VPMenuLink" data-v-515abb69 data-v-3a51b523><a class="VPLink link" href="/jiang225638.github.io/css/" data-v-3a51b523><!--[-->css<!--]--></a></div><!--]--><!--[--><div class="VPMenuLink" data-v-515abb69 data-v-3a51b523><a class="VPLink link" href="/jiang225638.github.io/html" data-v-3a51b523><!--[-->html<!--]--></a></div><!--]--><!--[--><div class="VPMenuLink" data-v-515abb69 data-v-3a51b523><a class="VPLink link" href="/jiang225638.github.io/vue/" data-v-3a51b523><!--[-->vue<!--]--></a></div><!--]--><!--[--><div class="VPMenuLink" data-v-515abb69 data-v-3a51b523><a class="VPLink link" href="/jiang225638.github.io/react/" data-v-3a51b523><!--[-->react<!--]--></a></div><!--]--><!--[--><div class="VPMenuLink" data-v-515abb69 data-v-3a51b523><a class="VPLink link" href="/jiang225638.github.io/nestjs/base/" data-v-3a51b523><!--[-->nestjs<!--]--></a></div><!--]--><!--]--></div><!--[--><!--]--></div></div></div><!--]--><!--[--><div class="VPFlyout VPNavBarMenuGroup" data-v-f8d8594d data-v-a89f3eba><button type="button" class="button" aria-haspopup="true" aria-expanded="false" data-v-a89f3eba><span class="text" data-v-a89f3eba><!----><span data-v-a89f3eba>阅尽繁华</span><span class="vpi-chevron-down text-icon" data-v-a89f3eba></span></span></button><div class="menu" data-v-a89f3eba><div class="VPMenu" data-v-a89f3eba data-v-515abb69><div class="items" data-v-515abb69><!--[--><!--[--><div class="VPMenuLink" data-v-515abb69 data-v-3a51b523><a class="VPLink link" href="/jiang225638.github.io/excellentArticle/" data-v-3a51b523><!--[-->读过的精彩<!--]--></a></div><!--]--><!--]--></div><!--[--><!--]--></div></div></div><!--]--><!--]--></nav><!----><div class="VPNavBarAppearance appearance" data-v-8b5c946b data-v-4d613e6d><button class="VPSwitch VPSwitchAppearance" type="button" role="switch" title="Switch to dark theme" aria-checked="false" data-v-4d613e6d data-v-16f5ff2d data-v-cad15de3><span class="check" data-v-cad15de3><span class="icon" data-v-cad15de3><!--[--><span class="vpi-sun sun" data-v-16f5ff2d></span><span class="vpi-moon moon" data-v-16f5ff2d></span><!--]--></span></span></button></div><!----><div class="VPFlyout VPNavBarExtra extra" data-v-8b5c946b data-v-6b0d4d8f data-v-a89f3eba><button type="button" class="button" aria-haspopup="true" aria-expanded="false" aria-label="extra navigation" data-v-a89f3eba><span class="vpi-more-horizontal icon" data-v-a89f3eba></span></button><div class="menu" data-v-a89f3eba><div class="VPMenu" data-v-a89f3eba data-v-515abb69><!----><!--[--><!--[--><!----><div class="group" data-v-6b0d4d8f><div class="item appearance" data-v-6b0d4d8f><p class="label" data-v-6b0d4d8f>外观</p><div class="appearance-action" data-v-6b0d4d8f><button class="VPSwitch VPSwitchAppearance" type="button" role="switch" title="Switch to dark theme" aria-checked="false" data-v-6b0d4d8f data-v-16f5ff2d data-v-cad15de3><span class="check" data-v-cad15de3><span class="icon" data-v-cad15de3><!--[--><span class="vpi-sun sun" data-v-16f5ff2d></span><span class="vpi-moon moon" data-v-16f5ff2d></span><!--]--></span></span></button></div></div></div><!----><!--]--><!--]--></div></div></div><!--[--><!--]--><button type="button" class="VPNavBarHamburger hamburger" aria-label="mobile navigation" aria-expanded="false" aria-controls="VPNavScreen" data-v-8b5c946b data-v-fcef9adc><span class="container" data-v-fcef9adc><span class="top" data-v-fcef9adc></span><span class="middle" data-v-fcef9adc></span><span class="bottom" data-v-fcef9adc></span></span></button></div></div></div></div><div class="divider" data-v-8b5c946b><div class="divider-line" data-v-8b5c946b></div></div></div><!----></header><div class="VPLocalNav has-sidebar empty" data-v-113dd8ef data-v-a5ecb6f7><div class="container" data-v-a5ecb6f7><button class="menu" aria-expanded="false" aria-controls="VPSidebarNav" data-v-a5ecb6f7><span class="vpi-align-left menu-icon" data-v-a5ecb6f7></span><span class="menu-text" data-v-a5ecb6f7>Menu</span></button><div class="VPLocalNavOutlineDropdown" style="--vp-vh:0px;" data-v-a5ecb6f7 data-v-f6fc1f21><button data-v-f6fc1f21>返回顶部</button><!----></div></div></div><aside class="VPSidebar" data-v-113dd8ef data-v-5e416fd2><div class="curtain" data-v-5e416fd2></div><nav class="nav" id="VPSidebarNav" aria-labelledby="sidebar-aria-label" tabindex="-1" data-v-5e416fd2><span class="visually-hidden" id="sidebar-aria-label" data-v-5e416fd2> Sidebar Navigation </span><!--[--><!--]--><!--[--><div class="group" data-v-5e416fd2><section class="VPSidebarItem level-0 has-active" data-v-5e416fd2 data-v-a1b3e29f><div class="item" role="button" tabindex="0" data-v-a1b3e29f><div class="indicator" data-v-a1b3e29f></div><h2 class="text" data-v-a1b3e29f>每日阅读</h2><!----></div><div class="items" data-v-a1b3e29f><!--[--><div class="VPSidebarItem level-1 is-link" data-v-a1b3e29f data-v-a1b3e29f><div class="item" data-v-a1b3e29f><div class="indicator" data-v-a1b3e29f></div><a class="VPLink link link" href="/jiang225638.github.io/excellentArticle/2024-04-11/" data-v-a1b3e29f><!--[--><p class="text" data-v-a1b3e29f>前端常见的安全攻击方式、原理、以及如何防护！</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-a1b3e29f data-v-a1b3e29f><div class="item" data-v-a1b3e29f><div class="indicator" data-v-a1b3e29f></div><a class="VPLink link link" href="/jiang225638.github.io/excellentArticle/2024-04-12/" data-v-a1b3e29f><!--[--><p class="text" data-v-a1b3e29f>为什么需要缓存</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-a1b3e29f data-v-a1b3e29f><div class="item" data-v-a1b3e29f><div class="indicator" data-v-a1b3e29f></div><a class="VPLink link link" href="/jiang225638.github.io/excellentArticle/2024-04-15/" data-v-a1b3e29f><!--[--><p class="text" data-v-a1b3e29f>面试官：Vue3中什么是Reactive的懒响应性？</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-a1b3e29f data-v-a1b3e29f><div class="item" data-v-a1b3e29f><div class="indicator" data-v-a1b3e29f></div><a class="VPLink link link" href="/jiang225638.github.io/excellentArticle/2024-04-16/" data-v-a1b3e29f><!--[--><p class="text" data-v-a1b3e29f>搞懂 Vue3 中的各种 ref: toRef,toRefs,isRef,unref...</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-a1b3e29f data-v-a1b3e29f><div class="item" data-v-a1b3e29f><div class="indicator" data-v-a1b3e29f></div><a class="VPLink link link" href="/jiang225638.github.io/excellentArticle/2024-04-17/" data-v-a1b3e29f><!--[--><p class="text" data-v-a1b3e29f>基于nginx+ffmpeg+vue3+TypeScript在网页上显示监控的实时画面</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-a1b3e29f data-v-a1b3e29f><div class="item" data-v-a1b3e29f><div class="indicator" data-v-a1b3e29f></div><a class="VPLink link link" href="/jiang225638.github.io/excellentArticle/2024-04-18/" data-v-a1b3e29f><!--[--><p class="text" data-v-a1b3e29f>面试官：只知道v-model是modelValue语法糖，那你可以走了</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-a1b3e29f data-v-a1b3e29f><div class="item" data-v-a1b3e29f><div class="indicator" data-v-a1b3e29f></div><a class="VPLink link link" href="/jiang225638.github.io/excellentArticle/2024-04-23/" data-v-a1b3e29f><!--[--><p class="text" data-v-a1b3e29f>TypeScript很麻烦💔，不想使用！</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-a1b3e29f data-v-a1b3e29f><div class="item" data-v-a1b3e29f><div class="indicator" data-v-a1b3e29f></div><a class="VPLink link link" href="/jiang225638.github.io/excellentArticle/2024-04-24/" data-v-a1b3e29f><!--[--><p class="text" data-v-a1b3e29f>一文掌握 TS 高级类型编程</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-a1b3e29f data-v-a1b3e29f><div class="item" data-v-a1b3e29f><div class="indicator" data-v-a1b3e29f></div><a class="VPLink link link" href="/jiang225638.github.io/excellentArticle/2024-05-06/" data-v-a1b3e29f><!--[--><p class="text" data-v-a1b3e29f>前端视频人像实时捕获技术,超干货!!!</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-a1b3e29f data-v-a1b3e29f><div class="item" data-v-a1b3e29f><div class="indicator" data-v-a1b3e29f></div><a class="VPLink link link" href="/jiang225638.github.io/excellentArticle/2024-05-07/" data-v-a1b3e29f><!--[--><p class="text" data-v-a1b3e29f>5分钟带你了解【前端装饰器】，“高大上”的“基础知识”</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-a1b3e29f data-v-a1b3e29f><div class="item" data-v-a1b3e29f><div class="indicator" data-v-a1b3e29f></div><a class="VPLink link link" href="/jiang225638.github.io/excellentArticle/2024-05-15/" data-v-a1b3e29f><!--[--><p class="text" data-v-a1b3e29f>开发阶段！跨域问题多种解决方案的精华总结</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-a1b3e29f data-v-a1b3e29f><div class="item" data-v-a1b3e29f><div class="indicator" data-v-a1b3e29f></div><a class="VPLink link link" href="/jiang225638.github.io/excellentArticle/2024-05-17/" data-v-a1b3e29f><!--[--><p class="text" data-v-a1b3e29f>ES7、ES8、ES9、ES10、ES11、ES12都增加了哪些新特性？</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-a1b3e29f data-v-a1b3e29f><div class="item" data-v-a1b3e29f><div class="indicator" data-v-a1b3e29f></div><a class="VPLink link link" href="/jiang225638.github.io/excellentArticle/2024-05-23/" data-v-a1b3e29f><!--[--><p class="text" data-v-a1b3e29f>前端需要知道的缓存知识总结</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-a1b3e29f data-v-a1b3e29f><div class="item" data-v-a1b3e29f><div class="indicator" data-v-a1b3e29f></div><a class="VPLink link link" href="/jiang225638.github.io/excellentArticle/2024-05-30/" data-v-a1b3e29f><!--[--><p class="text" data-v-a1b3e29f>领导被我的花式console.log吸引了！直接写入公司公共库！</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-a1b3e29f data-v-a1b3e29f><div class="item" data-v-a1b3e29f><div class="indicator" data-v-a1b3e29f></div><a class="VPLink link link" href="/jiang225638.github.io/excellentArticle/2024-05-31/" data-v-a1b3e29f><!--[--><p class="text" data-v-a1b3e29f>赶快收藏！全网最佳websocket封装：完美支持断网重连、自动心跳！</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-a1b3e29f data-v-a1b3e29f><div class="item" data-v-a1b3e29f><div class="indicator" data-v-a1b3e29f></div><a class="VPLink link link" href="/jiang225638.github.io/excellentArticle/2024-06-07/" data-v-a1b3e29f><!--[--><p class="text" data-v-a1b3e29f>CSS 动画从入门到高手!</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-a1b3e29f data-v-a1b3e29f><div class="item" data-v-a1b3e29f><div class="indicator" data-v-a1b3e29f></div><a class="VPLink link link" href="/jiang225638.github.io/excellentArticle/2024-06-13/" data-v-a1b3e29f><!--[--><p class="text" data-v-a1b3e29f>1000个判断条件难道要写了1000个 if ? 一文教你如何实现分支优化</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-a1b3e29f data-v-a1b3e29f><div class="item" data-v-a1b3e29f><div class="indicator" data-v-a1b3e29f></div><a class="VPLink link link" href="/jiang225638.github.io/excellentArticle/2024-06-14/" data-v-a1b3e29f><!--[--><p class="text" data-v-a1b3e29f>在 web 地图上的踩坑指南</p><!--]--></a><!----></div><!----></div><!--]--></div></section></div><!--]--><!--[--><!--]--></nav></aside><div class="VPContent has-sidebar" id="VPContent" data-v-113dd8ef data-v-5dd8a3f8><div class="VPDoc has-sidebar has-aside" data-v-5dd8a3f8 data-v-c77b2230><!--[--><!--]--><div class="container" data-v-c77b2230><div class="aside" data-v-c77b2230><div class="aside-curtain" data-v-c77b2230></div><div class="aside-container" data-v-c77b2230><div class="aside-content" data-v-c77b2230><div class="VPDocAside" data-v-c77b2230 data-v-ad0540fa><!--[--><!--]--><!--[--><!--]--><nav aria-labelledby="doc-outline-aria-label" class="VPDocAsideOutline" data-v-ad0540fa data-v-61ef0afc><div class="content" data-v-61ef0afc><div class="outline-marker" data-v-61ef0afc></div><div aria-level="2" class="outline-title" id="doc-outline-aria-label" role="heading" data-v-61ef0afc>本页目录</div><ul class="VPDocOutlineItem root" data-v-61ef0afc data-v-86a1b51c><!--[--><!--]--></ul></div></nav><!--[--><!--]--><div class="spacer" data-v-ad0540fa></div><!--[--><!--]--><!----><!--[--><!--]--><!--[--><!--]--></div></div></div></div><div class="content" data-v-c77b2230><div class="content-container" data-v-c77b2230><!--[--><!--]--><main class="main" data-v-c77b2230><div style="position:relative;" class="vp-doc _jiang225638_github_io_excellentArticle_2024-04-18_" data-v-c77b2230><div><h1 id="面试官-只知道v-model是modelvalue语法糖-那你可以走了" tabindex="-1">面试官：只知道v-model是modelValue语法糖，那你可以走了 <a class="header-anchor" href="#面试官-只知道v-model是modelvalue语法糖-那你可以走了" aria-label="Permalink to &quot;面试官：只知道v-model是modelValue语法糖，那你可以走了&quot;">​</a></h1><p><img src="/jiang225638.github.io/assets/excellentArticle/2024-04-18/0.jpeg" alt="img"></p><h2 id="通过debug的方式带你看vue源码" tabindex="-1">通过debug的方式带你看vue源码 <a class="header-anchor" href="#通过debug的方式带你看vue源码" aria-label="Permalink to &quot;通过debug的方式带你看vue源码&quot;">​</a></h2><p><strong>前言</strong></p><p>我们每天都在用<code>v-model</code>，并且大家都知道在vue3中<code>v-model</code>是<code>:modelValue</code>和<code>@update:modelValue</code>的语法糖。那你知道<code>v-model</code>指令是如何变成组件上的<code>modelValue</code>属性和<code>@update:modelValue</code>事件呢？将<code>v-model</code>指令转换为<code>modelValue</code>属性和<code>@update:modelValue</code>事件这一过程是在编译时还是运行时进行的呢？</p><h1 id="先说结论" tabindex="-1"><strong>先说结论</strong> <a class="header-anchor" href="#先说结论" aria-label="Permalink to &quot;**先说结论**&quot;">​</a></h1><p>下面这个是我画的处理<code>v-model</code>指令的完整流程图：</p><p><img src="/jiang225638.github.io/assets/excellentArticle/2024-04-18/640-1713444830906-136.png" alt="medium-zoom"></p><p>首先会调用<code>parse</code>函数将template模块中的代码转换为AST抽象语法树，此时使用<code>v-model</code>的node节点的props属性中还是<code>v-model</code>。接着会调用<code>transform</code>函数，经过<code>transform</code>函数处理后在<code>node</code>节点中多了一个<code>codegenNode</code>属性。在<code>codegenNode</code>属性中我们看到没有<code>v-model</code>指令，取而代之的是<code>modelValue</code>和<code>onUpdate:modelValue</code>属性。经过<code>transform</code>函数处理后已经将<code>v-model</code>指令编译为<code>modelValue</code>和<code>onUpdate:modelValue</code>属性，此时还是AST抽象语法树。所以接下来就是调用<code>generate</code>函数将AST抽象语法树转换为<code>render</code>函数，到此为止编译时做的事情已经做完了，<strong>经过编译时的处理<code>v-model</code>指令已经变成了<code>modelValue</code>和<code>onUpdate:modelValue</code>属性。</strong></p><p>接着就是运行时阶段，在浏览器中执行<code>render</code>函数生成虚拟DOM。在生成虚拟DOM的过程中由于props属性中有<code>modelValue</code>和<code>onUpdate:modelValue</code>属性，所以就会给组件对象加上<code>modelValue</code>属性和<code>@update:modelValue</code>事件。最后就是调用<code>mount</code>方法将虚拟DOM转换为真实DOM。<strong>所以<code>v-model</code>指令转换为<code>modelValue</code>属性和<code>@update:modelValue</code>事件这一过程是在编译时进行的。</strong></p><h1 id="什么是编译时-什么是运行时" tabindex="-1"><strong>什么是编译时？什么是运行时？</strong> <a class="header-anchor" href="#什么是编译时-什么是运行时" aria-label="Permalink to &quot;**什么是编译时？什么是运行时？**&quot;">​</a></h1><p>vue是一个编译时+运行时一起工作的框架，之前有小伙伴私信我说自己傻傻分不清楚在vue中什么时候是编译时，什么时候是运行时。要回答小伙伴的这个问题我们要从一个vue文件是如何渲染到浏览器窗口中说起。</p><p>我们的vue代码一般都是写在后缀名为vue的文件上，显然浏览器是不认识vue文件的，浏览器只认识html、css、jss等文件类型。所以第一步就是通过webpack或者vite将一个vue文件编译为一个包含<code>render</code>函数的js文件，在这一步中代码的执行环境是在nodejs中进行，也就是我们所说的编译时。相比浏览器端来说能够拿到的权限更多，也能做更多的事情。后面就是执行<code>render</code>函数生成虚拟DOM，再调用浏览器的DOM API根据虚拟DOM生成真实DOM挂载到浏览器上。在第一步后面的这些过程中代码执行环境都是在浏览器中，也就是我们所说的运行时。在客户端渲染的场景下，一句话总结就是：代码跑在nodejs端的时候就是编译时，代码跑在浏览器端的时候就是运行时。</p><p><img src="/jiang225638.github.io/assets/excellentArticle/2024-04-18/640-1713444830906-137.png" alt="medium-zoom"></p><h1 id="举个例子" tabindex="-1"><strong>举个例子</strong> <a class="header-anchor" href="#举个例子" aria-label="Permalink to &quot;**举个例子**&quot;">​</a></h1><p>我们来看一个<code>v-model</code>的例子，父组件<code>index.vue</code>的代码如下：</p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>&lt;template&gt;</span></span>
<span class="line"><span>  &lt;CommonChild v-model=&quot;inputValue&quot; /&gt;</span></span>
<span class="line"><span>  &lt;p&gt;input value is: {{ inputValue }}&lt;/p&gt;</span></span>
<span class="line"><span>&lt;/template&gt;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>&lt;script setup lang=&quot;ts&quot;&gt;</span></span>
<span class="line"><span>import { ref } from &quot;vue&quot;;</span></span>
<span class="line"><span>import CommonChild from &quot;./child.vue&quot;;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>const inputValue = ref();</span></span>
<span class="line"><span>&lt;/script&gt;</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><p>我们上面是一个很简单的<code>v-model</code>的例子，在<code>CommonChild</code>子组件上使用<code>v-model</code>绑定一个叫<code>inputValue</code>的ref变量，然后将这个<code>inputValue</code>变量渲染到p标签上面。</p><p>前面我们已经讲过了客户端渲染的场景下，在nodejs端工作的时候是编译时，在浏览器端工作的时候是运行时。那我们现在先来看看经过<code>编译时</code>阶段处理后，刚刚进入到浏览器端<code>运行时</code>阶段的js代码是什么样的。我们要如何在浏览器中找到这个js文件呢？其实很简单直接在network上面找到你的那个vue文件就行了，比如我这里的文件是<code>index.vue</code>，那我只需要在network上面找叫<code>index.vue</code>的文件就行了。但是需要注意一下network上面有两个<code>index.vue</code>的js请求，分别是template模块+script模块编译后的js文件，和style模块编译后的js文件。</p><p>那怎么区分这两个<code>index.vue</code>文件呢？很简单，通过query就可以区分。由style模块编译后的js文件的URL中有type=style的query，如下图所示：</p><p><img src="/jiang225638.github.io/assets/excellentArticle/2024-04-18/640-1713444830906-138.png" alt="medium-zoom"></p><p>这时有的小伙伴就开始疑惑了不是说好的浏览器不认识vue文件吗？怎么这里的文件名称是<code>index.vue</code>而不是<code>index.js</code>呢？其实很简单，在开发环境时<code>index.vue</code>文件是在<code>App.vue</code>文件中import导入的，而<code>App.vue</code>文件是在<code>main.js</code>文件中import导入的。所以当浏览器中执行<code>main.js</code>的代码时发现import导入了<code>App.vue</code>文件，那浏览器就会去加载<code>App.vue</code>文件。当浏览器加载完<code>App.vue</code>文件后执行时发现import导入了<code>index.vue</code>文件，所以浏览器就会去加载<code>index.vue</code>文件，而不是<code>index.js</code>文件。</p><p>至于什么时候将<code>index.vue</code>文件中的template模块、script模块、style模块编译成js代码，我们在 <a href="https://mp.weixin.qq.com/s?__biz=MzkzMzYzNzMzMQ==&amp;mid=2247483961&amp;idx=1&amp;sn=da58c998ee2c70629603ea08d47de425&amp;scene=21#wechat_redirect" target="_blank" rel="noreferrer">通过debug搞清楚.vue文件怎么变成.js文件</a>文章中已经讲过了当import加载一个文件时会触发<code>@vitejs/plugin-vue</code>包中的<code>transform</code>钩子函数，在这个<code>transform</code>钩子函数中会将template模块、script模块、style模块编译成js代码。所以在浏览器中拿到的index.vue文件就是经过编译后的js代码了。</p><p>现在我们在浏览器的network中来看刚刚进入编译时<code>index.vue</code>文件代码，简化后的代码如下：</p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>import {</span></span>
<span class="line"><span>  Fragment as _Fragment,</span></span>
<span class="line"><span>  createElementBlock as _createElementBlock,</span></span>
<span class="line"><span>  createElementVNode as _createElementVNode,</span></span>
<span class="line"><span>  createVNode as _createVNode,</span></span>
<span class="line"><span>  defineComponent as _defineComponent,</span></span>
<span class="line"><span>  openBlock as _openBlock,</span></span>
<span class="line"><span>  toDisplayString as _toDisplayString,</span></span>
<span class="line"><span>  ref,</span></span>
<span class="line"><span>} from &quot;/node_modules/.vite/deps/vue.js?v=23bfe016&quot;;</span></span>
<span class="line"><span>import CommonChild from &quot;/src/components/vModel/child.vue?t=1710943659056&quot;;</span></span>
<span class="line"><span>import &quot;/src/components/vModel/index.vue?vue&amp;type=style&amp;index=0&amp;scoped=0ebe7d62&amp;lang.css&quot;;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>const _sfc_main = _defineComponent({</span></span>
<span class="line"><span>  __name: &quot;index&quot;,</span></span>
<span class="line"><span>  setup(__props, { expose: __expose }) {</span></span>
<span class="line"><span>    __expose();</span></span>
<span class="line"><span>    const inputValue = ref();</span></span>
<span class="line"><span>    const __returned__ = { inputValue, CommonChild };</span></span>
<span class="line"><span>    return __returned__;</span></span>
<span class="line"><span>  },</span></span>
<span class="line"><span>});</span></span>
<span class="line"><span></span></span>
<span class="line"><span>function _sfc_render(_ctx, _cache, $props, $setup, $data, $options) {</span></span>
<span class="line"><span>  return (</span></span>
<span class="line"><span>    _openBlock(),</span></span>
<span class="line"><span>    _createElementBlock(</span></span>
<span class="line"><span>      _Fragment,</span></span>
<span class="line"><span>      null,</span></span>
<span class="line"><span>      [</span></span>
<span class="line"><span>        _createVNode(</span></span>
<span class="line"><span>          $setup[&quot;CommonChild&quot;],</span></span>
<span class="line"><span>          {</span></span>
<span class="line"><span>            modelValue: $setup.inputValue,</span></span>
<span class="line"><span>            &quot;onUpdate:modelValue&quot;:</span></span>
<span class="line"><span>              _cache[0] ||</span></span>
<span class="line"><span>              (_cache[0] = ($event) =&gt; ($setup.inputValue = $event)),</span></span>
<span class="line"><span>          },</span></span>
<span class="line"><span>          null,</span></span>
<span class="line"><span>          8,</span></span>
<span class="line"><span>          [&quot;modelValue&quot;]</span></span>
<span class="line"><span>        ),</span></span>
<span class="line"><span>        _createElementVNode(</span></span>
<span class="line"><span>          &quot;p&quot;,</span></span>
<span class="line"><span>          null,</span></span>
<span class="line"><span>          &quot;input value is: &quot; + _toDisplayString($setup.inputValue),</span></span>
<span class="line"><span>          1</span></span>
<span class="line"><span>          /* TEXT */</span></span>
<span class="line"><span>        ),</span></span>
<span class="line"><span>      ],</span></span>
<span class="line"><span>      64</span></span>
<span class="line"><span>      /* STABLE_FRAGMENT */</span></span>
<span class="line"><span>    )</span></span>
<span class="line"><span>  );</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>_sfc_main.render = _sfc_render;</span></span>
<span class="line"><span>export default _sfc_main;</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br><span class="line-number">37</span><br><span class="line-number">38</span><br><span class="line-number">39</span><br><span class="line-number">40</span><br><span class="line-number">41</span><br><span class="line-number">42</span><br><span class="line-number">43</span><br><span class="line-number">44</span><br><span class="line-number">45</span><br><span class="line-number">46</span><br><span class="line-number">47</span><br><span class="line-number">48</span><br><span class="line-number">49</span><br><span class="line-number">50</span><br><span class="line-number">51</span><br><span class="line-number">52</span><br><span class="line-number">53</span><br><span class="line-number">54</span><br><span class="line-number">55</span><br><span class="line-number">56</span><br><span class="line-number">57</span><br><span class="line-number">58</span><br></div></div><p>从上面的代码中我们可以看到编译后的js代码主要分为两块，第一块是<code>_sfc_main</code>组件对象，里面有name属性和setup方法。一个vue组件在运行时实际就是一个对象，这里的<code>_sfc_main</code>就是一个vue组件对象。至于<code>defineComponent</code>函数的作用是在定义 Vue 组件时提供类型推导的辅助函数，所以在我们这个场景没什么用。我们接着来看第二块<code>_sfc_render</code>，从名字我想你应该已经猜到了他是一个render函数。执行这个<code>_sfc_render</code>函数就会生成虚拟DOM，然后再由虚拟DOM生成浏览器上面的真实DOM。</p><p>我们再来看这个<code>render</code>函数，在这个<code>render</code>函数前面会调用<code>openBlock</code>函数和<code>createElementBlock</code>函数。他的作用是在编译时尽可能的提取多的关键信息，可以减少运行时比较新旧虚拟DOM带来的性能开销，我们这篇文章不关注这点，所以我们接下来会直接看下面的<code>_createVNode</code>函数和<code>_createElementVNode</code>函数。</p><h1 id="v-model语法糖怎么工作的" tabindex="-1"><strong><code>v-model</code>语法糖怎么工作的</strong> <a class="header-anchor" href="#v-model语法糖怎么工作的" aria-label="Permalink to &quot;**`v-model`语法糖怎么工作的**&quot;">​</a></h1><p>我们接着来看<code>render</code>函数中的<code>_createVNode</code>函数和<code>_createElementVNode</code>函数，代码如下：</p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>import {</span></span>
<span class="line"><span>  createElementVNode as _createElementVNode,</span></span>
<span class="line"><span>  createVNode as _createVNode,</span></span>
<span class="line"><span>} from &quot;/node_modules/.vite/deps/vue.js?v=23bfe016&quot;;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>_createVNode(</span></span>
<span class="line"><span>  $setup[&quot;CommonChild&quot;],</span></span>
<span class="line"><span>  {</span></span>
<span class="line"><span>    modelValue: $setup.inputValue,</span></span>
<span class="line"><span>    &quot;onUpdate:modelValue&quot;:</span></span>
<span class="line"><span>      _cache[0] ||</span></span>
<span class="line"><span>      (_cache[0] = ($event) =&gt; ($setup.inputValue = $event)),</span></span>
<span class="line"><span>  },</span></span>
<span class="line"><span>  null,</span></span>
<span class="line"><span>  8,</span></span>
<span class="line"><span>  [&quot;modelValue&quot;]</span></span>
<span class="line"><span>),</span></span>
<span class="line"><span>_createElementVNode(</span></span>
<span class="line"><span>  &quot;p&quot;,</span></span>
<span class="line"><span>  null,</span></span>
<span class="line"><span>  &quot;input value is: &quot; + _toDisplayString($setup.inputValue),</span></span>
<span class="line"><span>  1</span></span>
<span class="line"><span>  /* TEXT */</span></span>
<span class="line"><span>),</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br></div></div><p>从这两个函数的名字我想你也能猜出来他们的作用是创建虚拟DOM，再仔细一看这两个函数不就是对应的我们template模块中的这两行代码吗。</p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>&lt;CommonChild v-model=&quot;inputValue&quot; /&gt;</span></span>
<span class="line"><span>&lt;p&gt;input value is: {{ inputValue }}&lt;/p&gt;</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>第一个<code>_createVNode</code>函数对应的是<code>CommonChild</code>，第二个<code>_createElementVNode</code>对应的是<code>p</code>标签。我们将重点放在<code>_createVNode</code>函数上，从import导入来看<code>_createVNode</code>函数是从vue中导出的<code>createVNode</code>函数。你是不是觉得<code>createVNode</code>这个名字比较熟悉呢，其实在 vue官网中有提到。</p><blockquote><p>“</p><p><code>h()</code> 是 <strong>hyperscript</strong> 的简称——意思是“能生成 HTML (超文本标记语言) 的 JavaScript”。这个名字来源于许多虚拟 DOM 实现默认形成的约定。一个更准确的名称应该是 <code>createVnode()</code>，但当你需要多次使用渲染函数时，一个简短的名字会更省力。</p></blockquote><p>vue官网中<code>h()</code> 函数用于生成虚拟DOM，其实<code>h()函数</code>底层就是调用的<code>createVnode</code>函数。同样的<code>createVnode</code>函数和<code>h()</code> 函数接收的参数也差不多，第一个参数可以是一个组件对象也可以是像<code>p</code>这样的html标签，也可以是一个虚拟DOM。第二个参数为给组件或者html标签传递的props属性或者attribute。第三个参数是该节点的children子节点。现在我们再来仔细看这个<code>_createVNode</code>函数你应该已经明白了：</p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>_createVNode(</span></span>
<span class="line"><span>  $setup[&quot;CommonChild&quot;],</span></span>
<span class="line"><span>  {</span></span>
<span class="line"><span>    modelValue: $setup.inputValue,</span></span>
<span class="line"><span>    &quot;onUpdate:modelValue&quot;:</span></span>
<span class="line"><span>      _cache[0] ||</span></span>
<span class="line"><span>      (_cache[0] = ($event) =&gt; ($setup.inputValue = $event)),</span></span>
<span class="line"><span>  },</span></span>
<span class="line"><span>  null,</span></span>
<span class="line"><span>  8,</span></span>
<span class="line"><span>  [&quot;modelValue&quot;]</span></span>
<span class="line"><span>),</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br></div></div><p>我们在 <a href="https://mp.weixin.qq.com/s?__biz=MzkzMzYzNzMzMQ==&amp;mid=2247483842&amp;idx=1&amp;sn=9d8f9ad19d8946603d681d2598f7a143&amp;scene=21#wechat_redirect" target="_blank" rel="noreferrer">Vue 3 的 setup语法糖到底是什么东西？</a>文章中已经讲过了<code>render</code>函数中的<code>$setup</code>变量就是<code>setup</code>函数的返回值经过<code>Proxy</code>处理后的对象，由于<code>Proxy</code>的拦截处理让我们在template中使用ref变量时无需再写<code>.value</code>。在上面的<code>setup</code>函数中我们看到<code>CommonChild</code>组件对象也在返回值对象中，所以这里传入给<code>createVNode</code>函数的第一个参数为<code>CommonChild</code>组件对象。</p><p>我们再来看第二个参数对象，对象中有两个key，分别是<code>modelValue</code>和<code>onUpdate:modelValue</code>。这两个key就是传递给<code>CommonChild</code>组件的两个props，等等这里有两个问题。第一个问题是这里怎么是<code>onUpdate:modelValue</code>，我们知道的<code>v-model</code>是<code>:modelValue</code>和<code>@update:modelValue</code>的语法糖，不是说好的<code>@update</code>怎么变成了<code>onUpdate</code>了呢？第二个问题是<code>onUpdate:modelValue</code>明显是事件监听而不是props属性，怎么是“通过props属性”而不是“通过事件”传递给了<code>CommonChild</code>子组件呢？</p><p>因为在编译时处理v-on事件监听会将监听的事件首字母变成大写然后在前面加一个<code>on</code>，塞到props属性对象中，所以这里才是<code>onUpdate:modelValue</code>。所以在组件上不管是v-bind的attribute和prop，还是v-on事件监听，经过编译后都会被塞到一个大的props对象中。以<code>on</code>开头的属性我们都视作事件监听，用于和普通的attribute和prop区分。所以你在组件上绑定一个<code>onConfirm</code>属性，属性值为一个<code>handleClick</code>的函数。在子组件中使用<code>emit(&#39;confirm&#39;)</code>是可以触发<code>handleClick</code>函数的执行的，但是一般情况下还是不要这样写，维护代码的人会看着一脸蒙蔽的。</p><p>我们接着来看传递给<code>CommonChild</code>组件的这两个属性值。</p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>{</span></span>
<span class="line"><span>  modelValue: $setup.inputValue,</span></span>
<span class="line"><span>  &quot;onUpdate:modelValue&quot;:</span></span>
<span class="line"><span>    _cache[0] ||</span></span>
<span class="line"><span>    (_cache[0] = ($event) =&gt; ($setup.inputValue = $event)),</span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p>第一个<code>modelValue</code>的属性值是<code>$setup.inputValue</code>。前面我们已经讲过了<code>$setup.inputValue</code>就是指向<code>setup</code>中定义的名为<code>inputValue</code>的ref变量，所以第一个属性的作用就是给<code>CommonChild</code>组件添加<code>:modelValue=&quot;inputValue&quot;</code>的属性。</p><p>我们再来看第二个属性<code>onUpdate:modelValue</code>，属性值为<code>_cache[0] ||(_cache[0] = ($event) =&gt; ($setup.inputValue = $event))</code>。这里为什么要加一个<code>_cache</code>缓存呢？原因是每次页面刷新都会重新触发<code>render</code>函数的执行，如果不加缓存那不就变成了每次执行<code>render</code>函数都会生成一个事件处理函数。这里的事件处理函数也很简单，接收一个<code>$event</code>变量然后赋值给<code>setup</code>中的<code>inputValue</code>变量。接收的<code>$event</code>变量就是我们在子组件中调用<code>emit</code>触发事件传过来的第二个变量，比如：<code>emit(&#39;update:modelValue&#39;, &#39;helllo word&#39;)</code>。为什么是第二个变量呢？是因为<code>emit</code>函数接收的第一个变量为要触发的事件名称。所以第二个属性的作用就是给<code>CommonChild</code>组件添加<code>@update:modelValue</code>的事件绑定。</p><h1 id="编译时如何处理v-model" tabindex="-1"><strong>编译时如何处理v-model</strong> <a class="header-anchor" href="#编译时如何处理v-model" aria-label="Permalink to &quot;**编译时如何处理v-model**&quot;">​</a></h1><p>前面我们已经讲过了在运行时已经拿到了key为<code>modelValue</code>和<code>onUpdate:modelValue</code>的props属性对象了，我们知道这个<code>props</code>属性对象是在编译时由<code>v-model</code>指令编译而来的，那在这个编译过程中是如何处理<code>v-model</code>指令的呢？请看下面编译时的流程图：</p><p><img src="/jiang225638.github.io/assets/excellentArticle/2024-04-18/640-1713444830906-139.png" alt="medium-zoom">compile-progress</p><p>首先会调用<code>parse</code>函数将template模块中的代码转换为AST抽象语法树，此时使用<code>v-model</code>的node节点的props属性中还是<code>v-model</code>。接着会调用<code>transform</code>函数，经过<code>transform</code>函数处理后在<code>node</code>节点中多了一个<code>codegenNode</code>属性。在<code>codegenNode</code>属性中我们看到没有<code>v-model</code>指令，取而代之的是<code>modelValue</code>和<code>onUpdate:modelValue</code>属性。经过<code>transform</code>函数处理后已经将<code>v-model</code>指令编译为<code>modelValue</code>和<code>onUpdate:modelValue</code>属性，此时还是AST抽象语法树。所以接下来就是调用<code>generate</code>函数将AST抽象语法树转换为<code>render</code>函数，到此为止编译时做的事情已经做完了。</p><h2 id="parse函数" tabindex="-1"><strong><code>parse</code>函数</strong> <a class="header-anchor" href="#parse函数" aria-label="Permalink to &quot;**`parse`函数**&quot;">​</a></h2><p>首先是使用<code>parse</code>函数将template模块中的代码编译成AST抽象语法树，在这个过程中会使用到大量的正则表达式对字符串进行解析。我们直接来看编译后的AST抽象语法树是什么样子：</p><p><img src="/jiang225638.github.io/assets/excellentArticle/2024-04-18/640-1713444830906-140.png" alt="medium-zoom"></p><p>从上图中我们可以看到使用<code>v-model</code>指令的node节点中有了<code>name</code>为<code>model</code>和<code>rawName</code>为<code>v-model</code>的props了，明显可以看出将template中code代码字符串转换为AST抽象语法树时没有处理<code>v-model</code>指令。那么什么时候处理的<code>v-model</code>指令呢？</p><h2 id="transform函数" tabindex="-1"><strong><code>transform</code>函数</strong> <a class="header-anchor" href="#transform函数" aria-label="Permalink to &quot;**`transform`函数**&quot;">​</a></h2><p>其实是在后面的一个<code>transform</code>函数中处理的，在这个函数中主要调用的是<code>traverseNode</code>函数处理AST抽象语法树。在<code>traverseNode</code>函数中会去递归的去处理AST抽象语法树中的所有node节点，这也解释了为什么还要在<code>transform</code>函数中再抽取出来一个<code>traverseNode</code>函数。</p><p>我们再来思考一个问题，由于<code>traverseNode</code>函数会处理node节点的所有情况，比如<code>v-model</code>指令、<code>v-for</code>指令、<code>v-on</code>、<code>v-bind</code>。如果将这些的逻辑全部都放到<code>traverseNode</code>函数中，那<code>traverseNode</code>函数的体量将会是非常大的。所以抽取出来一个<code>nodeTransforms</code>的概念，这个<code>nodeTransforms</code>是一个数组。里面存了一组<code>transform</code>函数，用于处理node节点。每个<code>transform</code>函数都有自己独有的作用，比如<code>transformModel</code>函数用于处理<code>v-model</code>指令，<code>transformIf</code>函数用于处理<code>v-if</code>指令。我们来看看经过<code>transform</code>函数处理后的AST抽象语法树是什么样的：</p><p><img src="/jiang225638.github.io/assets/excellentArticle/2024-04-18/640-1713444830906-141.png" alt="medium-zoom"></p><p>从上图中我们可以看到同一个使用<code>v-model</code>指令的node节点，经过<code>transform</code>函数处理后的和第一步经过<code>parse</code>函数处理后比起来node节点最外层多了一个<code>codegenNode</code>属性。</p><p>我们接下来看看<code>codegenNode</code>属性里面是什么样的：</p><p><img src="/jiang225638.github.io/assets/excellentArticle/2024-04-18/640-1713444830906-142.png" alt="medium-zoom"></p><p>从上图中我们可以看到在<code>codegenNode</code>中还有一个<code>props</code>属性，在<code>props</code>属性下面还有一个<code>properties</code>属性。这个<code>properties</code>属性是一个数组，里面就是存的是node节点经过transform函数处理后的props属性的内容。我们看到<code>properties</code>数组中的每一个item都有<code>key</code>和<code>value</code>属性，我想你应该已经反应过来了，这个<code>key</code>和<code>value</code>分别对应的是props属性中的属性名和属性值。从上图中我们看到第一个属性的属性名<code>key</code>的值为<code>modelValue</code>，属性值<code>value</code>为<code>$setup.inputValue</code>。这个刚好就对应上<code>v-model</code>指令编译后的<code>:modelValue=&quot;$setup.inputValue&quot;</code>。</p><p>我们再来接着看第二个属性：</p><p><img src="/jiang225638.github.io/assets/excellentArticle/2024-04-18/640-1713444830906-143.png" alt="medium-zoom"></p><p>从上图中我们同样也可以看到第二个属性的属性名<code>key</code>的值为<code>onUpdate:modelValue</code>，属性值<code>value</code>的值拼起来就是为一串箭头函数，和我们前面编译后的代码一模一样。第二个属性刚好就对应上<code>v-model</code>指令编译后的<code>@update:modelValue=&quot;($event) =&gt; ($setup.inputValue = $event)&quot;</code>。</p><p>从上面的分析我们看到经过<code>transform</code>函数的处理后已经将<code>v-model</code>指令处理为对应的代码了，接下来我们要做的事情就是调用<code>generate</code>函数将AST抽象语法树转换成<code>render</code>函数</p><h2 id="generate函数" tabindex="-1"><strong><code>generate</code>函数</strong> <a class="header-anchor" href="#generate函数" aria-label="Permalink to &quot;**`generate`函数**&quot;">​</a></h2><p>在<code>generate</code>函数中会递归遍历AST抽象语法树，然后生成对应的浏览器可执行的js代码。如下图：</p><p><img src="/jiang225638.github.io/assets/excellentArticle/2024-04-18/640-1713444830906-144.png" alt="medium-zoom"></p><p>从上图中我们可以看到经过<code>generate</code>函数处理后生成的<code>render</code>函数和我们之前在浏览器的network中看到的经过编译后的<code>index.vue</code>文件中的<code>render</code>函数一模一样。这也证明了<code>modelValue</code>属性和<code>@update:modelValue</code>事件塞到组件上是在编译时进行的。</p><h1 id="总结" tabindex="-1"><strong>总结</strong> <a class="header-anchor" href="#总结" aria-label="Permalink to &quot;**总结**&quot;">​</a></h1><p>现在我们可以回答前面提的两个问题了：</p><ul><li><p><code>v-model</code>指令是如何变成组件上的<code>modelValue</code>属性和<code>@update:modelValue</code>事件呢？</p><p>首先会调用<code>parse</code>函数将template模块中的代码转换为AST抽象语法树，此时使用<code>v-model</code>的node节点的props属性中还是<code>v-model</code>。接着会调用<code>transform</code>函数，经过<code>transform</code>函数处理后在<code>node</code>节点中多了一个<code>codegenNode</code>属性。在<code>codegenNode</code>属性中我们看到没有<code>v-model</code>指令，取而代之的是<code>modelValue</code>和<code>onUpdate:modelValue</code>属性。经过<code>transform</code>函数处理后已经将<code>v-model</code>指令编译为<code>modelValue</code>和<code>onUpdate:modelValue</code>属性。其实在运行时<code>onUpdate:modelValue</code>属性就是等同于<code>@update:modelValue</code>事件。接着就是调用<code>generate</code>函数，将AST抽象语法树生成<code>render</code>函数。然后在浏览器中执行<code>render</code>函数时，将拿到的<code>modelValue</code>和<code>onUpdate:modelValue</code>属性塞到组件对象上，所以在组件上就多了两个<code>modelValue</code>属性和<code>@update:modelValue</code>事件。</p></li><li><p>将<code>v-model</code>指令转换为<code>modelValue</code>属性和<code>@update:modelValue</code>事件这一过程是在编译时还是运行时进行的呢？</p><p>从上面的问题答案中我们可以知道将<code>v-model</code>指令转换为<code>modelValue</code>属性和<code>@update:modelValue</code>事件这一过程是在编译时进行的。</p></li></ul><p>在<code>transform</code>函数中是调用<code>transformModel</code>函数处理<code>v-model</code>指令，这篇文章没有深入到<code>transformModel</code>函数源码内去讲解。如果大家对<code>transformModel</code>函数的源码感兴趣请在评论区留言或者给我发信息，我会在后面的文章安排上。</p></div></div></main><footer class="VPDocFooter" data-v-c77b2230 data-v-bf946607><!--[--><!--]--><div class="edit-info" data-v-bf946607><!----><div class="last-updated" data-v-bf946607><p class="VPLastUpdated" data-v-bf946607 data-v-e4787f1d>上次更新: <time datetime="2024-04-19T09:48:28.000Z" data-v-e4787f1d></time></p></div></div><nav class="prev-next" aria-labelledby="doc-footer-aria-label" data-v-bf946607><span class="visually-hidden" id="doc-footer-aria-label" data-v-bf946607>Pager</span><div class="pager" data-v-bf946607><a class="VPLink link pager-link prev" href="/jiang225638.github.io/excellentArticle/2024-04-17/" data-v-bf946607><!--[--><span class="desc" data-v-bf946607>上一篇</span><span class="title" data-v-bf946607>基于nginx+ffmpeg+vue3+TypeScript在网页上显示监控的实时画面</span><!--]--></a></div><div class="pager" data-v-bf946607><a class="VPLink link pager-link next" href="/jiang225638.github.io/excellentArticle/2024-04-23/" data-v-bf946607><!--[--><span class="desc" data-v-bf946607>下一篇</span><span class="title" data-v-bf946607>TypeScript很麻烦💔，不想使用！</span><!--]--></a></div></nav></footer><!--[--><!--]--></div></div></div><!--[--><!--]--></div></div><!----><!--[--><!--]--></div></div>
    <script>window.__VP_HASH_MAP__=JSON.parse("{\"excellentarticle_2024-04-15_index.md\":\"AWh0rJ1S\",\"index.md\":\"AgnDj-Ju\",\"excellentarticle_2024-05-15_index.md\":\"8oeydFAm\",\"excellentarticle_2024-05-30_index.md\":\"DiqzAtz5\",\"excellentarticle_2024-04-12_index.md\":\"T-0U1Jrd\",\"excellentarticle_2024-05-17_index.md\":\"BZyVn2oO\",\"excellentarticle_2024-04-11_index.md\":\"Dr-WwyAf\",\"excellentarticle_2024-06-07_index.md\":\"CUwi3zoe\",\"excellentarticle_2024-05-23_index.md\":\"DEjNeofZ\",\"excellentarticle_2024-06-13_index.md\":\"DyhKbLS3\",\"excellentarticle_2024-04-18_index.md\":\"al8Mrv1-\",\"excellentarticle_2024-05-06_index.md\":\"DdGsMbat\",\"js_2024-04-19_index.md\":\"Dd59zSTx\",\"thewayforward_index.md\":\"DTCFOHVZ\",\"ts_index.md\":\"B6C9DrWK\",\"test_index.md\":\"CBvZcCue\",\"thewayforward_ihaveroadbythailand_index.md\":\"DFpsswUG\",\"excellentarticle_2024-06-14_index.md\":\"Dfv80epL\",\"html_index.md\":\"D5Q9Q5wk\",\"excellentarticle_index.md\":\"DVj0kIXp\",\"excellentarticle_2024-05-07_index.md\":\"c_qTpamf\",\"excellentarticle_2024-04-17_index.md\":\"oiGL4yNI\",\"excellentarticle_2024-04-23_index.md\":\"BwXncBvf\",\"css_index.md\":\"BwPKUiH0\",\"workexperience_index.md\":\"CBcezmfH\",\"nav_index.md\":\"Ddd-69Cb\",\"excellentarticle_2024-04-16_index.md\":\"DedHOO5r\",\"nestjs_base_index.md\":\"DwxnEy0n\",\"nestjs_index.md\":\"B4OFgJzj\",\"rotelearning_index.md\":\"W_5unZwS\",\"nestjs_providers_index.md\":\"BUt2TCxA\",\"react_index.md\":\"BrcSeDX4\",\"rotelearning_react_index.md\":\"DGc0ESKz\",\"nestjs_proconfig_index.md\":\"B7OsbO_i\",\"dailyrecord_index.md\":\"Ks6EYief\",\"excellentarticle_2024-05-31_index.md\":\"Bk1qRfvo\",\"excellentarticle_2024-04-24_index.md\":\"3yRHxAKh\",\"vue_index.md\":\"C2B7fIU4\",\"rotelearning_vue_index.md\":\"owmjKQvh\",\"rotelearning_javascript_index.md\":\"CXPiWPmc\",\"test.md\":\"BTM7QfEa\",\"nestjs_prisma_index.md\":\"D08f6x4j\",\"nestjs_module_index.md\":\"-UwFmFC6\",\"js_index.md\":\"DmUZ88no\",\"js_2024-05-23_index.md\":\"bhTTRliX\"}");window.__VP_SITE_DATA__=JSON.parse("{\"lang\":\"zh-CN\",\"dir\":\"ltr\",\"title\":\"想躺不敢躺\",\"description\":\"啥都不会，只想躺平，看看小说，听听音乐，晒晒太阳\",\"base\":\"/jiang225638.github.io/\",\"head\":[],\"router\":{\"prefetchLinks\":true},\"appearance\":true,\"themeConfig\":{\"i18nRouting\":false,\"logo\":\"/logo1.gif\",\"nav\":[{\"text\":\"看穿尘世\",\"items\":[{\"text\":\"js\",\"link\":\"/js/\"},{\"text\":\"TS\",\"link\":\"/ts/\"},{\"text\":\"css\",\"link\":\"/css/\"},{\"text\":\"html\",\"link\":\"/html\"},{\"text\":\"vue\",\"link\":\"/vue/\"},{\"text\":\"react\",\"link\":\"/react/\"},{\"text\":\"nestjs\",\"link\":\"/nestjs/base/\"}]},{\"text\":\"阅尽繁华\",\"items\":[{\"text\":\"读过的精彩\",\"link\":\"/excellentArticle/\"}]}],\"sidebar\":{\"/excellentArticle/\":[{\"text\":\"每日阅读\",\"items\":[{\"text\":\"前端常见的安全攻击方式、原理、以及如何防护！\",\"link\":\"/excellentArticle/2024-04-11/\"},{\"text\":\"为什么需要缓存\",\"link\":\"/excellentArticle/2024-04-12/\"},{\"text\":\"面试官：Vue3中什么是Reactive的懒响应性？\",\"link\":\"/excellentArticle/2024-04-15/\"},{\"text\":\"搞懂 Vue3 中的各种 ref: toRef,toRefs,isRef,unref...\",\"link\":\"/excellentArticle/2024-04-16/\"},{\"text\":\"基于nginx+ffmpeg+vue3+TypeScript在网页上显示监控的实时画面\",\"link\":\"/excellentArticle/2024-04-17/\"},{\"text\":\"面试官：只知道v-model是modelValue语法糖，那你可以走了\",\"link\":\"/excellentArticle/2024-04-18/\"},{\"text\":\"TypeScript很麻烦💔，不想使用！\",\"link\":\"/excellentArticle/2024-04-23/\"},{\"text\":\"一文掌握 TS 高级类型编程\",\"link\":\"/excellentArticle/2024-04-24/\"},{\"text\":\"前端视频人像实时捕获技术,超干货!!!\",\"link\":\"/excellentArticle/2024-05-06/\"},{\"text\":\"5分钟带你了解【前端装饰器】，“高大上”的“基础知识”\",\"link\":\"/excellentArticle/2024-05-07/\"},{\"text\":\"开发阶段！跨域问题多种解决方案的精华总结\",\"link\":\"/excellentArticle/2024-05-15/\"},{\"text\":\"ES7、ES8、ES9、ES10、ES11、ES12都增加了哪些新特性？\",\"link\":\"/excellentArticle/2024-05-17/\"},{\"text\":\"前端需要知道的缓存知识总结\",\"link\":\"/excellentArticle/2024-05-23/\"},{\"text\":\"领导被我的花式console.log吸引了！直接写入公司公共库！\",\"link\":\"/excellentArticle/2024-05-30/\"},{\"text\":\"赶快收藏！全网最佳websocket封装：完美支持断网重连、自动心跳！\",\"link\":\"/excellentArticle/2024-05-31/\"},{\"text\":\"CSS 动画从入门到高手!\",\"link\":\"/excellentArticle/2024-06-07/\"},{\"text\":\"1000个判断条件难道要写了1000个 if ? 一文教你如何实现分支优化\",\"link\":\"/excellentArticle/2024-06-13/\"},{\"text\":\"在 web 地图上的踩坑指南\",\"link\":\"/excellentArticle/2024-06-14/\"}]}],\"/roteLearning/\":[{\"text\":\"需要死记硬背的八股\",\"items\":[{\"text\":\"一丢丢vue面试题\",\"link\":\"/roteLearning/vue/\"},{\"text\":\"复习复习44个react知识点\",\"link\":\"/roteLearning/react/\"},{\"text\":\"进阶进阶！复习50个JavaScript「进阶」知识点\",\"link\":\"/roteLearning/javaScript/\"}]}],\"/js/\":[{\"text\":\"积累\",\"items\":[{\"text\":\"提高开发效率的10个JavaScript技巧\",\"link\":\"/js/2024-04-19/\"},{\"text\":\"万字总结 JS 数据结构与常用的算法\",\"link\":\"/js/2024-05-23/\"}]}],\"/nestjs/\":[{\"text\":\"原文请上后盾人官网查看www.houdunren.com\",\"items\":[{\"text\":\"基础知识\",\"link\":\"/nestjs/base/\"},{\"text\":\"提供者\",\"link\":\"/nestjs/providers/\"},{\"text\":\"模块\",\"link\":\"/nestjs/module/\"},{\"text\":\"项目配置\",\"link\":\"/nestjs/proConfig/\"},{\"text\":\"prisma\",\"link\":\"/nestjs/prisma/\"}]}],\"/theWayForward/\":[{\"text\":\"原文请上后盾人官网查看www.houdunren.com\",\"items\":[{\"text\":\"基础知识\",\"link\":\"/theWayForward/iHaveRoadbyThailand/\"}]}]},\"outline\":{\"level\":\"deep\",\"label\":\"本页目录\"},\"darkModeSwitchLabel\":\"外观\",\"returnToTopLabel\":\"返回顶部\",\"lastUpdatedText\":\"上次更新\",\"docFooter\":{\"prev\":\"上一篇\",\"next\":\"下一篇\"}},\"locales\":{},\"scrollOffset\":134,\"cleanUrls\":true}");</script>
    
  </body>
</html>