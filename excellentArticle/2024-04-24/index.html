<!DOCTYPE html>
<html lang="zh-CN" dir="ltr">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>一文掌握 TS 高级类型编程 | 想躺不敢躺</title>
    <meta name="description" content="啥都不会，只想躺平，看看小说，听听音乐，晒晒太阳">
    <meta name="generator" content="VitePress v1.2.3">
    <link rel="preload stylesheet" href="/jiang225638.github.io/assets/style.BtA91yrk.css" as="style">
    
    <script type="module" src="/jiang225638.github.io/assets/app.BPieM4j3.js"></script>
    <link rel="preload" href="/jiang225638.github.io/assets/inter-roman-latin.Di8DUHzh.woff2" as="font" type="font/woff2" crossorigin="">
    <link rel="modulepreload" href="/jiang225638.github.io/assets/chunks/framework.BaCLUa54.js">
    <link rel="modulepreload" href="/jiang225638.github.io/assets/chunks/theme.C_6q4W3l.js">
    <link rel="modulepreload" href="/jiang225638.github.io/assets/excellentArticle_2024-04-24_index.md.DX_eAfBy.lean.js">
    <meta name="theme-color" content="#3eaf7c">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <link rel="apple-touch-icon" href="/favicon.ico">
    <link rel="mask-icon" href="/favicon.ico" color="#3eaf7c">
    <meta name="msapplication-TileImage" content="/favicon.ico">
    <meta name="msapplication-TileColor" content="#000000">
    <script id="check-dark-mode">(()=>{const e=localStorage.getItem("vitepress-theme-appearance")||"auto",a=window.matchMedia("(prefers-color-scheme: dark)").matches;(!e||e==="auto"?a:e==="dark")&&document.documentElement.classList.add("dark")})();</script>
    <script id="check-mac-os">document.documentElement.classList.toggle("mac",/Mac|iPhone|iPod|iPad/i.test(navigator.platform));</script>
  </head>
  <body>
    <div id="app"><div class="Layout" data-v-f1b35dac><!--[--><!--]--><!--[--><span tabindex="-1" data-v-a3940849></span><a href="#VPContent" class="VPSkipLink visually-hidden" data-v-a3940849> Skip to content </a><!--]--><!----><header class="VPNav" data-v-f1b35dac data-v-1cc85562><div class="VPNavBar has-sidebar top" data-v-1cc85562 data-v-97f14d0d><div class="wrapper" data-v-97f14d0d><div class="container" data-v-97f14d0d><div class="title" data-v-97f14d0d><div class="VPNavBarTitle has-sidebar" data-v-97f14d0d data-v-c66a7b34><a class="title" href="/jiang225638.github.io/" data-v-c66a7b34><!--[--><!--]--><!--[--><img class="VPImage logo" src="/jiang225638.github.io/logo1.gif" alt data-v-24f35562><!--]--><span data-v-c66a7b34>想躺不敢躺</span><!--[--><!--]--></a></div></div><div class="content" data-v-97f14d0d><div class="content-body" data-v-97f14d0d><!--[--><!--]--><div class="VPNavBarSearch search" data-v-97f14d0d><!----></div><nav aria-labelledby="main-nav-aria-label" class="VPNavBarMenu menu" data-v-97f14d0d data-v-174fef3d><span id="main-nav-aria-label" class="visually-hidden" data-v-174fef3d>Main Navigation</span><!--[--><!--[--><div class="VPFlyout VPNavBarMenuGroup" data-v-174fef3d data-v-6dfd016a><button type="button" class="button" aria-haspopup="true" aria-expanded="false" data-v-6dfd016a><span class="text" data-v-6dfd016a><!----><span data-v-6dfd016a>看穿尘世</span><span class="vpi-chevron-down text-icon" data-v-6dfd016a></span></span></button><div class="menu" data-v-6dfd016a><div class="VPMenu" data-v-6dfd016a data-v-f4790d7c><div class="items" data-v-f4790d7c><!--[--><!--[--><div class="VPMenuLink" data-v-f4790d7c data-v-b8b8d55f><a class="VPLink link" href="/jiang225638.github.io/js/" data-v-b8b8d55f><!--[-->js<!--]--></a></div><!--]--><!--[--><div class="VPMenuLink" data-v-f4790d7c data-v-b8b8d55f><a class="VPLink link" href="/jiang225638.github.io/ts/" data-v-b8b8d55f><!--[-->TS<!--]--></a></div><!--]--><!--[--><div class="VPMenuLink" data-v-f4790d7c data-v-b8b8d55f><a class="VPLink link" href="/jiang225638.github.io/css/" data-v-b8b8d55f><!--[-->css<!--]--></a></div><!--]--><!--[--><div class="VPMenuLink" data-v-f4790d7c data-v-b8b8d55f><a class="VPLink link" href="/jiang225638.github.io/html" data-v-b8b8d55f><!--[-->html<!--]--></a></div><!--]--><!--[--><div class="VPMenuLink" data-v-f4790d7c data-v-b8b8d55f><a class="VPLink link" href="/jiang225638.github.io/vue/" data-v-b8b8d55f><!--[-->vue<!--]--></a></div><!--]--><!--[--><div class="VPMenuLink" data-v-f4790d7c data-v-b8b8d55f><a class="VPLink link" href="/jiang225638.github.io/react/" data-v-b8b8d55f><!--[-->react<!--]--></a></div><!--]--><!--[--><div class="VPMenuLink" data-v-f4790d7c data-v-b8b8d55f><a class="VPLink link" href="/jiang225638.github.io/nestjs/base/" data-v-b8b8d55f><!--[-->nestjs<!--]--></a></div><!--]--><!--]--></div><!--[--><!--]--></div></div></div><!--]--><!--[--><div class="VPFlyout VPNavBarMenuGroup" data-v-174fef3d data-v-6dfd016a><button type="button" class="button" aria-haspopup="true" aria-expanded="false" data-v-6dfd016a><span class="text" data-v-6dfd016a><!----><span data-v-6dfd016a>阅尽繁华</span><span class="vpi-chevron-down text-icon" data-v-6dfd016a></span></span></button><div class="menu" data-v-6dfd016a><div class="VPMenu" data-v-6dfd016a data-v-f4790d7c><div class="items" data-v-f4790d7c><!--[--><!--[--><div class="VPMenuLink" data-v-f4790d7c data-v-b8b8d55f><a class="VPLink link" href="/jiang225638.github.io/excellentArticle/" data-v-b8b8d55f><!--[-->读过的精彩<!--]--></a></div><!--]--><!--]--></div><!--[--><!--]--></div></div></div><!--]--><!--]--></nav><!----><div class="VPNavBarAppearance appearance" data-v-97f14d0d data-v-1b0aa71c><button class="VPSwitch VPSwitchAppearance" type="button" role="switch" title="Switch to dark theme" aria-checked="false" data-v-1b0aa71c data-v-4fef374c data-v-9a40cae5><span class="check" data-v-9a40cae5><span class="icon" data-v-9a40cae5><!--[--><span class="vpi-sun sun" data-v-4fef374c></span><span class="vpi-moon moon" data-v-4fef374c></span><!--]--></span></span></button></div><!----><div class="VPFlyout VPNavBarExtra extra" data-v-97f14d0d data-v-fad31be5 data-v-6dfd016a><button type="button" class="button" aria-haspopup="true" aria-expanded="false" aria-label="extra navigation" data-v-6dfd016a><span class="vpi-more-horizontal icon" data-v-6dfd016a></span></button><div class="menu" data-v-6dfd016a><div class="VPMenu" data-v-6dfd016a data-v-f4790d7c><!----><!--[--><!--[--><!----><div class="group" data-v-fad31be5><div class="item appearance" data-v-fad31be5><p class="label" data-v-fad31be5>外观</p><div class="appearance-action" data-v-fad31be5><button class="VPSwitch VPSwitchAppearance" type="button" role="switch" title="Switch to dark theme" aria-checked="false" data-v-fad31be5 data-v-4fef374c data-v-9a40cae5><span class="check" data-v-9a40cae5><span class="icon" data-v-9a40cae5><!--[--><span class="vpi-sun sun" data-v-4fef374c></span><span class="vpi-moon moon" data-v-4fef374c></span><!--]--></span></span></button></div></div></div><!----><!--]--><!--]--></div></div></div><!--[--><!--]--><button type="button" class="VPNavBarHamburger hamburger" aria-label="mobile navigation" aria-expanded="false" aria-controls="VPNavScreen" data-v-97f14d0d data-v-994bc578><span class="container" data-v-994bc578><span class="top" data-v-994bc578></span><span class="middle" data-v-994bc578></span><span class="bottom" data-v-994bc578></span></span></button></div></div></div></div><div class="divider" data-v-97f14d0d><div class="divider-line" data-v-97f14d0d></div></div></div><!----></header><div class="VPLocalNav has-sidebar empty" data-v-f1b35dac data-v-38bade04><div class="container" data-v-38bade04><button class="menu" aria-expanded="false" aria-controls="VPSidebarNav" data-v-38bade04><span class="vpi-align-left menu-icon" data-v-38bade04></span><span class="menu-text" data-v-38bade04>Menu</span></button><div class="VPLocalNavOutlineDropdown" style="--vp-vh:0px;" data-v-38bade04 data-v-bb994eae><button data-v-bb994eae>返回顶部</button><!----></div></div></div><aside class="VPSidebar" data-v-f1b35dac data-v-e2117a8e><div class="curtain" data-v-e2117a8e></div><nav class="nav" id="VPSidebarNav" aria-labelledby="sidebar-aria-label" tabindex="-1" data-v-e2117a8e><span class="visually-hidden" id="sidebar-aria-label" data-v-e2117a8e> Sidebar Navigation </span><!--[--><!--]--><!--[--><div class="group" data-v-e2117a8e><section class="VPSidebarItem level-0 has-active" data-v-e2117a8e data-v-a1b339c0><div class="item" role="button" tabindex="0" data-v-a1b339c0><div class="indicator" data-v-a1b339c0></div><h2 class="text" data-v-a1b339c0>每日阅读</h2><!----></div><div class="items" data-v-a1b339c0><!--[--><div class="VPSidebarItem level-1 is-link" data-v-a1b339c0 data-v-a1b339c0><div class="item" data-v-a1b339c0><div class="indicator" data-v-a1b339c0></div><a class="VPLink link link" href="/jiang225638.github.io/excellentArticle/2024-04-11/" data-v-a1b339c0><!--[--><p class="text" data-v-a1b339c0>前端常见的安全攻击方式、原理、以及如何防护！</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-a1b339c0 data-v-a1b339c0><div class="item" data-v-a1b339c0><div class="indicator" data-v-a1b339c0></div><a class="VPLink link link" href="/jiang225638.github.io/excellentArticle/2024-04-12/" data-v-a1b339c0><!--[--><p class="text" data-v-a1b339c0>为什么需要缓存</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-a1b339c0 data-v-a1b339c0><div class="item" data-v-a1b339c0><div class="indicator" data-v-a1b339c0></div><a class="VPLink link link" href="/jiang225638.github.io/excellentArticle/2024-04-15/" data-v-a1b339c0><!--[--><p class="text" data-v-a1b339c0>面试官：Vue3中什么是Reactive的懒响应性？</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-a1b339c0 data-v-a1b339c0><div class="item" data-v-a1b339c0><div class="indicator" data-v-a1b339c0></div><a class="VPLink link link" href="/jiang225638.github.io/excellentArticle/2024-04-16/" data-v-a1b339c0><!--[--><p class="text" data-v-a1b339c0>搞懂 Vue3 中的各种 ref: toRef,toRefs,isRef,unref...</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-a1b339c0 data-v-a1b339c0><div class="item" data-v-a1b339c0><div class="indicator" data-v-a1b339c0></div><a class="VPLink link link" href="/jiang225638.github.io/excellentArticle/2024-04-17/" data-v-a1b339c0><!--[--><p class="text" data-v-a1b339c0>基于nginx+ffmpeg+vue3+TypeScript在网页上显示监控的实时画面</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-a1b339c0 data-v-a1b339c0><div class="item" data-v-a1b339c0><div class="indicator" data-v-a1b339c0></div><a class="VPLink link link" href="/jiang225638.github.io/excellentArticle/2024-04-18/" data-v-a1b339c0><!--[--><p class="text" data-v-a1b339c0>面试官：只知道v-model是modelValue语法糖，那你可以走了</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-a1b339c0 data-v-a1b339c0><div class="item" data-v-a1b339c0><div class="indicator" data-v-a1b339c0></div><a class="VPLink link link" href="/jiang225638.github.io/excellentArticle/2024-04-23/" data-v-a1b339c0><!--[--><p class="text" data-v-a1b339c0>TypeScript很麻烦💔，不想使用！</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-a1b339c0 data-v-a1b339c0><div class="item" data-v-a1b339c0><div class="indicator" data-v-a1b339c0></div><a class="VPLink link link" href="/jiang225638.github.io/excellentArticle/2024-04-24/" data-v-a1b339c0><!--[--><p class="text" data-v-a1b339c0>一文掌握 TS 高级类型编程</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-a1b339c0 data-v-a1b339c0><div class="item" data-v-a1b339c0><div class="indicator" data-v-a1b339c0></div><a class="VPLink link link" href="/jiang225638.github.io/excellentArticle/2024-05-06/" data-v-a1b339c0><!--[--><p class="text" data-v-a1b339c0>前端视频人像实时捕获技术,超干货!!!</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-a1b339c0 data-v-a1b339c0><div class="item" data-v-a1b339c0><div class="indicator" data-v-a1b339c0></div><a class="VPLink link link" href="/jiang225638.github.io/excellentArticle/2024-05-07/" data-v-a1b339c0><!--[--><p class="text" data-v-a1b339c0>5分钟带你了解【前端装饰器】，“高大上”的“基础知识”</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-a1b339c0 data-v-a1b339c0><div class="item" data-v-a1b339c0><div class="indicator" data-v-a1b339c0></div><a class="VPLink link link" href="/jiang225638.github.io/excellentArticle/2024-05-15/" data-v-a1b339c0><!--[--><p class="text" data-v-a1b339c0>开发阶段！跨域问题多种解决方案的精华总结</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-a1b339c0 data-v-a1b339c0><div class="item" data-v-a1b339c0><div class="indicator" data-v-a1b339c0></div><a class="VPLink link link" href="/jiang225638.github.io/excellentArticle/2024-05-17/" data-v-a1b339c0><!--[--><p class="text" data-v-a1b339c0>ES7、ES8、ES9、ES10、ES11、ES12都增加了哪些新特性？</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-a1b339c0 data-v-a1b339c0><div class="item" data-v-a1b339c0><div class="indicator" data-v-a1b339c0></div><a class="VPLink link link" href="/jiang225638.github.io/excellentArticle/2024-05-23/" data-v-a1b339c0><!--[--><p class="text" data-v-a1b339c0>前端需要知道的缓存知识总结</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-a1b339c0 data-v-a1b339c0><div class="item" data-v-a1b339c0><div class="indicator" data-v-a1b339c0></div><a class="VPLink link link" href="/jiang225638.github.io/excellentArticle/2024-05-30/" data-v-a1b339c0><!--[--><p class="text" data-v-a1b339c0>领导被我的花式console.log吸引了！直接写入公司公共库！</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-a1b339c0 data-v-a1b339c0><div class="item" data-v-a1b339c0><div class="indicator" data-v-a1b339c0></div><a class="VPLink link link" href="/jiang225638.github.io/excellentArticle/2024-05-31/" data-v-a1b339c0><!--[--><p class="text" data-v-a1b339c0>赶快收藏！全网最佳websocket封装：完美支持断网重连、自动心跳！</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-a1b339c0 data-v-a1b339c0><div class="item" data-v-a1b339c0><div class="indicator" data-v-a1b339c0></div><a class="VPLink link link" href="/jiang225638.github.io/excellentArticle/2024-06-07/" data-v-a1b339c0><!--[--><p class="text" data-v-a1b339c0>CSS 动画从入门到高手!</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-a1b339c0 data-v-a1b339c0><div class="item" data-v-a1b339c0><div class="indicator" data-v-a1b339c0></div><a class="VPLink link link" href="/jiang225638.github.io/excellentArticle/2024-06-13/" data-v-a1b339c0><!--[--><p class="text" data-v-a1b339c0>1000个判断条件难道要写了1000个 if ? 一文教你如何实现分支优化</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-a1b339c0 data-v-a1b339c0><div class="item" data-v-a1b339c0><div class="indicator" data-v-a1b339c0></div><a class="VPLink link link" href="/jiang225638.github.io/excellentArticle/2024-06-14/" data-v-a1b339c0><!--[--><p class="text" data-v-a1b339c0>在 web 地图上的踩坑指南</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-a1b339c0 data-v-a1b339c0><div class="item" data-v-a1b339c0><div class="indicator" data-v-a1b339c0></div><a class="VPLink link link" href="/jiang225638.github.io/excellentArticle/2024-06-21/" data-v-a1b339c0><!--[--><p class="text" data-v-a1b339c0>一个reduce还能玩出这么多花样儿？中高级前端都知道的reduce函数高级用法</p><!--]--></a><!----></div><!----></div><!--]--></div></section></div><!--]--><!--[--><!--]--></nav></aside><div class="VPContent has-sidebar" id="VPContent" data-v-f1b35dac data-v-5310d02c><div class="VPDoc has-sidebar has-aside" data-v-5310d02c data-v-382fc3ef><!--[--><!--]--><div class="container" data-v-382fc3ef><div class="aside" data-v-382fc3ef><div class="aside-curtain" data-v-382fc3ef></div><div class="aside-container" data-v-382fc3ef><div class="aside-content" data-v-382fc3ef><div class="VPDocAside" data-v-382fc3ef data-v-1c9f498b><!--[--><!--]--><!--[--><!--]--><nav aria-labelledby="doc-outline-aria-label" class="VPDocAsideOutline" data-v-1c9f498b data-v-67c6fb25><div class="content" data-v-67c6fb25><div class="outline-marker" data-v-67c6fb25></div><div aria-level="2" class="outline-title" id="doc-outline-aria-label" role="heading" data-v-67c6fb25>本页目录</div><ul class="VPDocOutlineItem root" data-v-67c6fb25 data-v-80b33319><!--[--><!--]--></ul></div></nav><!--[--><!--]--><div class="spacer" data-v-1c9f498b></div><!--[--><!--]--><!----><!--[--><!--]--><!--[--><!--]--></div></div></div></div><div class="content" data-v-382fc3ef><div class="content-container" data-v-382fc3ef><!--[--><!--]--><main class="main" data-v-382fc3ef><div style="position:relative;" class="vp-doc _jiang225638_github_io_excellentArticle_2024-04-24_" data-v-382fc3ef><div><h1 id="一文掌握-ts-高级类型编程" tabindex="-1">一文掌握 TS 高级类型编程 <a class="header-anchor" href="#一文掌握-ts-高级类型编程" aria-label="Permalink to &quot;一文掌握 TS 高级类型编程&quot;">​</a></h1><p>[程序员成长指北](javascript:void(0)😉 <em>2024-04-24 08:46</em> <em>北京</em></p><p>以下文章来源于全栈前端精选 ，作者Nealyang</p><p><strong>全栈前端精选</strong>.</p><p>内容为王，精选为则。从前端到全栈，定期分享前端、客户端、Node、面试、职场感悟等相关高质量文章。小白的大神养成记，你我共勉！</p><p><img src="/jiang225638.github.io/assets/excellentArticle/2024-04-24/300.png" alt="img"></p><p><strong>程序员成长指北</strong></p><p>专注 Node.js 技术栈分享，从 前端 到 Node.js 再到 后端数据库，祝您成为优秀的高级 Node.js 全栈工程师。一个有趣的且乐于分享的人。座右铭：今天未完成的，明天更不会完成。</p><p>101篇原创内容</p><p>公众号</p><p><strong>大厂技术</strong> <strong>高级前端</strong> <strong>Node进阶</strong></p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>点击上方 程序员成长指北，关注公众号回复1，加入高级Node交流群</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><h2 id="前言" tabindex="-1"><strong>前言</strong> <a class="header-anchor" href="#前言" aria-label="Permalink to &quot;**前言**&quot;">​</a></h2><p>或许现在很多同学都在用 TypeScript，但是更可能大多数的同学并不会 TypeScript，他们用的，只不过是给 js 加了一些“注释”，然后洋洋得意“TypeScript 不过如此”</p><p><img src="/jiang225638.github.io/assets/excellentArticle/2024-04-24/640.jpeg" alt="medium-zoom"></p><p>但是偶尔看到一些“别人的代码”又会虎躯一震~ “什么？这还是我用的 TypeScript 嘛？”</p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>export interface StoreCreator {</span></span>
<span class="line"><span>  &lt;S, A extends Action, Ext extends {} = {}, StateExt extends {} = {}&gt;(</span></span>
<span class="line"><span>    reducer: Reducer&lt;S, A&gt;,</span></span>
<span class="line"><span>    enhancer?: StoreEnhancer&lt;Ext, StateExt&gt;</span></span>
<span class="line"><span>  ): Store&lt;S, A, UnknownIfNonSpecific&lt;StateExt&gt;&gt; &amp; Ext;</span></span>
<span class="line"><span>  &lt;</span></span>
<span class="line"><span>    S,</span></span>
<span class="line"><span>    A extends Action,</span></span>
<span class="line"><span>    Ext extends {} = {},</span></span>
<span class="line"><span>    StateExt extends {} = {},312321</span></span>
<span class="line"><span>    PreloadedState = S</span></span>
<span class="line"><span>  &gt;(</span></span>
<span class="line"><span>    reducer: Reducer&lt;S, A, PreloadedState&gt;,</span></span>
<span class="line"><span>    preloadedState?: PreloadedState | undefined,</span></span>
<span class="line"><span>    enhancer?: StoreEnhancer&lt;Ext&gt;</span></span>
<span class="line"><span>  ): Store&lt;S, A, UnknownIfNonSpecific&lt;StateExt&gt;&gt; &amp; Ext;</span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br></div></div><p>其实究其原因，无非就是我们没有真正去了解何为 TypeScript。我们常说 TypeScript 是 js 的超集，确实如此，我们通过 TS 可以使用到很多 js 还在提案中的功能（当然，如今有了 Babel。。。） <img src="/jiang225638.github.io/assets/excellentArticle/2024-04-24/640-1713929828532-1.webp" alt="medium-zoom"></p><p>所以 TypeScript 并不是什么神奇的东西，它只是在 js 基础上加了一些注释，让我们更容易理解代码的含义。所以！致使我们看不懂上面的代码。。。</p><p>如果你还是类型编程的小白（type-challenges simple 级别有压力者）,那么我们就来重新认识一下 TypeScript。</p><p><strong>TypeScript = 预实现 JS 提案+类型编程</strong></p><p>JavaScript 就像是一辆正在行驶的汽车，而 TypeScript 就像是这辆车的 GPS 和安全带。预实现 JavaScript 提案，就好比 GPS 里已经更新了一些还没正式开放的道路（即将来的 JavaScript 新特性），允许你提前探索和尝试；而类型编程，则像是安全带，它在你行驶过程中提供了额外的安全保障，确保你不会因为一些错误而“偏离道路”。</p><h2 id="什么是类型编程" tabindex="-1"><strong>什么是类型编程</strong> <a class="header-anchor" href="#什么是类型编程" aria-label="Permalink to &quot;**什么是类型编程**&quot;">​</a></h2><p>类型编程是 TypeScript 中一种强大的功能，它通过类型定义和操作使得开发者能以编程的方式抽象和转换数据结构。简单点来理解就是循环、条件等各种 JS 里面有的语法它都有，其中也包括变量。</p><p>假设你正在开发一款游戏，你需要定义一个玩家（Player）类型，它具备一些基本属性和能力。</p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>type Player = {</span></span>
<span class="line"><span>  name: string;</span></span>
<span class="line"><span>  health: number;</span></span>
<span class="line"><span>  inventory: string[];</span></span>
<span class="line"><span>};</span></span>
<span class="line"><span></span></span>
<span class="line"><span>function heal(player: Player, amount: number): Player {</span></span>
<span class="line"><span>  return {</span></span>
<span class="line"><span>    ...player,</span></span>
<span class="line"><span>    health: player.health + amount,</span></span>
<span class="line"><span>  };</span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br></div></div><p>上面的代码或许让你比较自信~嚯~这不就是我写的代码么。但是如果稍微复杂一些,比如：</p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>type IntersectionToObj&lt;T&gt; = {</span></span>
<span class="line"><span>  [K in keyof T]: T[K];</span></span>
<span class="line"><span>};</span></span>
<span class="line"><span>type PartialByKeys&lt;T, K = any&gt; = IntersectionToObj&lt;</span></span>
<span class="line"><span>  {</span></span>
<span class="line"><span>    [P in keyof T as P extends K ? P : never]?: T[P];</span></span>
<span class="line"><span>  } &amp; {</span></span>
<span class="line"><span>    [P in Exclude&lt;keyof T, K&gt;]: T[P];</span></span>
<span class="line"><span>  }</span></span>
<span class="line"><span>&gt;;</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div><p>为什么类型编程这么的“炫酷”（实用，可能很多同学还未感受到），实际的开发和使用中，我们使用的很少呢？</p><p>究其原因主要是对于多数日常开发任务来说，基本的类型注解提供了足够的安全性和便利性。在没有遇到需要复杂类型转换和操作的场景时，简单地使用类型注解已经可以极大地提高代码的质量和可维护性。因此，许多开发者可能没有迫切的需求去深入学习类型编程的高级概念。但是随着项目规模的增长和功能的复杂，类型编程的能力变得日益重要。掌握了类型编程的开发者能够编写出更加强大、灵活和可复用的代码，同时提升整个代码库的健壮性和可维护性。</p><h2 id="类型别名-type-aliases" tabindex="-1"><strong>类型别名 （Type Aliases）</strong> <a class="header-anchor" href="#类型别名-type-aliases" aria-label="Permalink to &quot;**类型别名 （Type Aliases）**&quot;">​</a></h2><p>类型别名允许你给一个类型起一个新名字。这不仅使类型更易于引用，也可以用来创建更复杂的类型。</p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>type Point = {</span></span>
<span class="line"><span>  x: number;</span></span>
<span class="line"><span>  y: number;</span></span>
<span class="line"><span>};</span></span>
<span class="line"><span></span></span>
<span class="line"><span>function logPoint(p: Point) {</span></span>
<span class="line"><span>  console.log(`${p.x}, ${p.y}`);</span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><p>在这个例子中，我们定义了一个 Point 类型，并在 logPoint 函数中使用它。类型别名使得代码更清晰、更具可读性</p><h2 id="类型编程基础" tabindex="-1"><strong>类型编程基础</strong> <a class="header-anchor" href="#类型编程基础" aria-label="Permalink to &quot;**类型编程基础**&quot;">​</a></h2><h3 id="接口-interfaces" tabindex="-1"><strong>接口（Interfaces）</strong> <a class="header-anchor" href="#接口-interfaces" aria-label="Permalink to &quot;**接口（Interfaces）**&quot;">​</a></h3><p>接口是定义对象形状的另一种方式，它们非常类似于类型别名，但它们更专注于对象结构的描述。接口还支持扩展（继承），这使得它们在描述复杂对象时更有优势。</p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>interface Person {</span></span>
<span class="line"><span>  name: string;</span></span>
<span class="line"><span>  age: number;</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>interface Employee extends Person {</span></span>
<span class="line"><span>  salary: number;</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>const employee: Employee = {</span></span>
<span class="line"><span>  name: &#39;John Doe&#39;,</span></span>
<span class="line"><span>  age: 30,</span></span>
<span class="line"><span>  salary: 50000,</span></span>
<span class="line"><span>};</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br></div></div><p>这里，Employee 接口扩展了 Person 接口，添加了 salary 属性。接口的扩展性提供了一种强大的方式来构建和维护类型系统。</p><h3 id="泛型-generics" tabindex="-1"><strong>泛型（Generics）</strong> <a class="header-anchor" href="#泛型-generics" aria-label="Permalink to &quot;**泛型（Generics）**&quot;">​</a></h3><blockquote><p>❝</p><p>类型编程中的变量</p></blockquote><p>泛型允许我们在定义函数或类时不指定具体的类型，而是使用类型变量（type variables）作为占位符。这些类型变量可以在函数或类被实例化时被具体的类型替换。这样，同一个函数或类就可以用于多种不同类型的数据，而不需要为每种数据类型编写重复的代码。</p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>class Wrapper&lt;T&gt; {</span></span>
<span class="line"><span>  value: T;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>  constructor(value: T) {</span></span>
<span class="line"><span>    this.value = value;</span></span>
<span class="line"><span>  }</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>let wrapper1 = new Wrapper&lt;string&gt;(&#39;myString&#39;); // 类型为 Wrapper&lt;string&gt;</span></span>
<span class="line"><span>let wrapper2 = new Wrapper&lt;number&gt;(100); // 类型为 Wrapper&lt;number&gt;</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div><p>在这个例子中，Wrapper 类是一个泛型类，它有一个类型参数 T。我们可以创建 Wrapper 类的实例，用于存储任何类型的数据</p><h3 id="类型守卫" tabindex="-1"><strong>类型守卫</strong> <a class="header-anchor" href="#类型守卫" aria-label="Permalink to &quot;**类型守卫**&quot;">​</a></h3><p>很多文章会把类型收窄和类型守卫混为一谈，他两密切相关，但是概念和侧重点不同。类型收窄指的是任何减少类型可能性的过程，这可以通过类型守卫来实现，但不限于此。类型收窄可以通过条件检查、类型断言、控制流分析等多种方式实现，并且是 TypeScript 类型系统中的一个核心概念。其目的是让编译器能够更精确地知道在某个特定的代码块中变量的类型。</p><p>类型守卫则是实现类型收窄的一种具体方式。它是一种运行时检查，可以让 <code>TypeScript</code> 编译器在某个作用域中识别出一个更具体的类型。类型守卫通常是一些表达式或函数，它们返回一个布尔值，用于检查某个变量是否为特定的类型或是否满足某个类型断言。</p><p>总结来说，类型收窄是指在代码的某个流程中，通过某些手段减少变量的可能类型，而类型守卫则是实现类型收窄的一种机制。类型守卫通常被用作类型收窄的手段之一。</p><h4 id="typeof-类型守卫" tabindex="-1"><strong>typeof 类型守卫</strong> <a class="header-anchor" href="#typeof-类型守卫" aria-label="Permalink to &quot;**typeof 类型守卫**&quot;">​</a></h4><p>使用 typeof 操作符可以检查一个变量是否为 JavaScript 的七种原始类型之一（<code>number、string、boolean、bigint、symbol、undefined、object</code>）。</p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>function padLeft(value: string, padding: string | number) {</span></span>
<span class="line"><span>  // typeof 类型守卫</span></span>
<span class="line"><span>  if (typeof padding === &#39;number&#39;) {</span></span>
<span class="line"><span>    return new Array(padding + 1).join(&#39; &#39;) + value;</span></span>
<span class="line"><span>  }</span></span>
<span class="line"><span>  if (typeof padding === &#39;string&#39;) {</span></span>
<span class="line"><span>    return padding + value;</span></span>
<span class="line"><span>  }</span></span>
<span class="line"><span>  throw new Error(`Expected string or number, got &#39;${padding}&#39;.`);</span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div><p>这里可能很多人会比较疑惑，typeof 这不是 Js 里的么？这里需要区分下，ts 类型编程中的关键字和 ts 中的关键字还有不一样的，包括后面要说到的 <code>instanceof</code> 和 <code>in</code></p><p><strong>JavaScript 中的 typeof</strong></p><p>在 JavaScript 中，typeof 是一个操作符，用于获取一个变量的基础类型。它返回一个表示变量数据类型的字符串。</p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>console.log(typeof &#39;hello&#39;); // &quot;string&quot;</span></span>
<span class="line"><span>console.log(typeof 42); // &quot;number&quot;</span></span>
<span class="line"><span>console.log(typeof true); // &quot;boolean&quot;</span></span>
<span class="line"><span>console.log(typeof undefined); // &quot;undefined&quot;</span></span>
<span class="line"><span>console.log(typeof {}); // &quot;object&quot;</span></span>
<span class="line"><span>console.log(typeof function () {}); // &quot;function&quot;</span></span>
<span class="line"><span>console.log(typeof Symbol(&#39;sym&#39;)); // &quot;symbol&quot;</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><p>JavaScript 中的 typeof 返回的类型有：&quot;number&quot;, &quot;string&quot;, &quot;boolean&quot;, &quot;undefined&quot;, &quot;object&quot;, &quot;function&quot;, 和 &quot;symbol&quot;。注意 null 会被错误地认为是 &quot;object&quot; 类型，这是 JavaScript 历史遗留的一个 bug。</p><p><strong>TypeScript 中的 typeof 类型守卫</strong></p><p>在 TypeScript 中，typeof 不仅可以用在运行时代码中判断变量类型，还可以用作类型守卫。当用在类型守卫上时，typeof 会被 TypeScript 的类型检查器识别，并在编译时进行类型收窄。</p><p>在这个上下文中，typeof 可以识别两种形式：一种是在 if 语句中作为类型断言使用，另一种是在类型别名或其他类型注解中使用。</p><p>从上面的例子看起来好像，但是放到下面这个例子就不一样了</p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>const person = { name: &#39;Nealyang&#39;, age: &#39;18&#39; };</span></span>
<span class="line"><span>type Kevin = typeof person;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// type Kevin = {</span></span>
<span class="line"><span>//   name: string;</span></span>
<span class="line"><span>//   age: string;</span></span>
<span class="line"><span>// }</span></span>
<span class="line"><span></span></span>
<span class="line"><span>function identity&lt;Type&gt;(arg: Type): Type {</span></span>
<span class="line"><span>  return arg;</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>type result = typeof identity;</span></span>
<span class="line"><span>// type result = &lt;Type&gt;(arg: Type) =&gt; Type</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br></div></div><h4 id="instanceof-类型守卫" tabindex="-1"><strong>instanceof 类型守卫</strong> <a class="header-anchor" href="#instanceof-类型守卫" aria-label="Permalink to &quot;**instanceof 类型守卫**&quot;">​</a></h4><p>instanceof 操作符用于类的实例，它检查一个实例是否属于某个类。</p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>class Bird {</span></span>
<span class="line"><span>  fly() {</span></span>
<span class="line"><span>    console.log(&#39;Flying&#39;);</span></span>
<span class="line"><span>  }</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>class Fish {</span></span>
<span class="line"><span>  swim() {</span></span>
<span class="line"><span>    console.log(&#39;Swimming&#39;);</span></span>
<span class="line"><span>  }</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>function move(pet: Bird | Fish) {</span></span>
<span class="line"><span>  // instanceof 类型守卫</span></span>
<span class="line"><span>  if (pet instanceof Bird) {</span></span>
<span class="line"><span>    pet.fly();</span></span>
<span class="line"><span>  } else if (pet instanceof Fish) {</span></span>
<span class="line"><span>    pet.swim();</span></span>
<span class="line"><span>  }</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>const myBird = new Bird();</span></span>
<span class="line"><span>const myFish = new Fish();</span></span>
<span class="line"><span>move(myBird);</span></span>
<span class="line"><span>move(myFish);</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br></div></div><h4 id="in-类型守卫" tabindex="-1"><strong>in 类型守卫</strong> <a class="header-anchor" href="#in-类型守卫" aria-label="Permalink to &quot;**in 类型守卫**&quot;">​</a></h4><p>使用 in 操作符可以检查一个对象是否拥有某个特定的属性。</p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>function move(pet: Bird | Fish) {</span></span>
<span class="line"><span>  // in 类型守卫</span></span>
<span class="line"><span>  if (&#39;fly&#39; in pet) {</span></span>
<span class="line"><span>    pet.fly();</span></span>
<span class="line"><span>  } else {</span></span>
<span class="line"><span>    pet.swim();</span></span>
<span class="line"><span>  }</span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><h4 id="自定义类型守卫" tabindex="-1"><strong>自定义类型守卫</strong> <a class="header-anchor" href="#自定义类型守卫" aria-label="Permalink to &quot;**自定义类型守卫**&quot;">​</a></h4><p>自定义类型守卫通常是通过定义一个函数来实现，这个函数返回一个类型谓词，形式为<code>parameterName is Type</code>。</p><p>假设有这么一个字段，它可能字符串也可能是数字：</p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>type numOrStrProp = number | string;</span></span>
<span class="line"><span>const isString = (arg: unknown): boolean =&gt; typeof arg === &#39;string&#39;;</span></span>
<span class="line"><span>function useIt(numOrStr: number | string) {</span></span>
<span class="line"><span>  if (isString(numOrStr)) {</span></span>
<span class="line"><span>    console.log(numOrStr.length);</span></span>
<span class="line"><span>  }</span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><p>看着没有任何问题的代码，但是 Ts 并不能准确推断出正确类型。</p><p><img src="/jiang225638.github.io/assets/excellentArticle/2024-04-24/640-1713929828533-2.webp" alt="medium-zoom"></p><p>这个时候就该使用 <code>is</code> 关键字了：</p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>export const isString = (arg: unknown): arg is string =&gt;</span></span>
<span class="line"><span>  typeof arg === &#39;string&#39;;</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>这只是以原始类型为成员的联合类型，我们完全可以扩展到各种场景上，先看一个简单的假值判断：</p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>export type Falsy = false | &#39;&#39; | 0 | null | undefined;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>export const isFalsy = (val: unknown): val is Falsy =&gt; !val;</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><h4 id="字面量类型守卫" tabindex="-1"><strong>字面量类型守卫</strong> <a class="header-anchor" href="#字面量类型守卫" aria-label="Permalink to &quot;**字面量类型守卫**&quot;">​</a></h4><p>字面量类型是 TypeScript 中一种特殊的子类型，可以用来确保变量的值与特定的字符串或数字字面量相匹配。</p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>type Action = { type: &#39;INCREMENT&#39; } | { type: &#39;DECREMENT&#39; };</span></span>
<span class="line"><span></span></span>
<span class="line"><span>function performAction(action: Action) {</span></span>
<span class="line"><span>  // 字面量类型守卫</span></span>
<span class="line"><span>  switch (action.type) {</span></span>
<span class="line"><span>    case &#39;INCREMENT&#39;:</span></span>
<span class="line"><span>      // 做一些递增的操作</span></span>
<span class="line"><span>      break;</span></span>
<span class="line"><span>    case &#39;DECREMENT&#39;:</span></span>
<span class="line"><span>      // 做一些递减的操作</span></span>
<span class="line"><span>      break;</span></span>
<span class="line"><span>  }</span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br></div></div><h4 id="类型守卫使用场景" tabindex="-1"><strong>类型守卫使用场景</strong> <a class="header-anchor" href="#类型守卫使用场景" aria-label="Permalink to &quot;**类型守卫使用场景**&quot;">​</a></h4><p>类型守卫在处理联合类型（union types）或者更复杂的类型组合时尤其有用。在实际应用中，类型守卫经常出现在以下场景：</p><ul><li>在函数中处理不同类型的参数；</li><li>在运行时检查某个对象是否符合接口或类的实例；</li><li>在 Redux 或类似状态管理库中处理不同类型的 action；</li><li>在处理 JSON 数据或第三方 API 的响应时确保类型安全。</li><li>类型守卫的使用可以大大增加代码的可读性和稳定性，它允许开发者撰写出既灵活又安全的类型逻辑，确保在编译时和运行时都不会遇到意外的类型错误。</li></ul><h3 id="keyof" tabindex="-1"><strong>keyof</strong> <a class="header-anchor" href="#keyof" aria-label="Permalink to &quot;**keyof**&quot;">​</a></h3><blockquote><p>❝</p><p>keyof 和索引类型是捆绑的一般，为了区分开，所以这里分开介绍，但是结合一起看，会更加清晰。</p></blockquote><p>对一个对象类型使用 keyof 操作符，跟 JavaScript 中的 Object.keys() 类似，区别就是 keyof 会返回该对象属性名组成的一个字符串或者数字字面量的联合。</p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>type Person = {</span></span>
<span class="line"><span>  name: string;</span></span>
<span class="line"><span>  age: number;</span></span>
<span class="line"><span>};</span></span>
<span class="line"><span>type Keys = keyof Person;</span></span>
<span class="line"><span>// type Keys = &quot;name&quot; | &quot;age&quot;</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p>keyof 关键字非常有用，因为它允许你基于对象类型的属性名来创建类型，这在处理对象和属性时提供了很高的类型安全性。</p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>function getProperty&lt;T, K extends keyof T&gt;(obj: T, key: K) {</span></span>
<span class="line"><span>  return obj[key]; // 安全地返回 obj 中 key 的属性值</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>const person: Person = {</span></span>
<span class="line"><span>  name: &#39;Alice&#39;,</span></span>
<span class="line"><span>  age: 25,</span></span>
<span class="line"><span>};</span></span>
<span class="line"><span></span></span>
<span class="line"><span>const name = getProperty(person, &#39;name&#39;); // 正确</span></span>
<span class="line"><span>const age = getProperty(person, &#39;age&#39;); // 正确</span></span>
<span class="line"><span>// const unknown = getProperty(person, &quot;unknown&quot;); // 错误：类型 &#39;&quot;unknown&quot;&#39; 不能赋值给类型 &#39;&quot;name&quot; | &quot;age&quot;&#39;</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br></div></div><p>但如果这个类型有一个 string 或者 number 类型的索引签名，keyof 则会直接返回这些类型：</p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>type Arrayish = { [n: number]: unknown };</span></span>
<span class="line"><span>type A = keyof Arrayish;</span></span>
<span class="line"><span>// type A = number</span></span>
<span class="line"><span></span></span>
<span class="line"><span>type Mapish = { [k: string]: boolean };</span></span>
<span class="line"><span>type M = keyof Mapish;</span></span>
<span class="line"><span>// type M = string | number</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><p>注意在这个例子中，M 是 string | number，这是因为 JavaScript 对象的属性名会被强制转为一个字符串，所以 obj[0] 和 obj[&quot;0&quot;] 是一样的。</p><p>简单可以理解为 string 可以包含 number，但是 number 不能转 string。</p><h2 id="类型编程进阶" tabindex="-1"><strong>类型编程进阶</strong> <a class="header-anchor" href="#类型编程进阶" aria-label="Permalink to &quot;**类型编程进阶**&quot;">​</a></h2><h3 id="索引类型" tabindex="-1"><strong>索引类型</strong> <a class="header-anchor" href="#索引类型" aria-label="Permalink to &quot;**索引类型**&quot;">​</a></h3><p>索引类型（Index Types）在 TypeScript 中是用来描述那些能够通过索引获取值的类型，如数组和特定结构的对象。</p><p>索引类型通常和一下两个高级特性密切相关：</p><h4 id="索引类型查询-keyof" tabindex="-1"><strong>索引类型查询（keyof）</strong> <a class="header-anchor" href="#索引类型查询-keyof" aria-label="Permalink to &quot;**索引类型查询（keyof）**&quot;">​</a></h4><p>索引类型查询使用 keyof 关键字来获取一个类型的所有属性键组成的联合类型。例如：</p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>interface Person {</span></span>
<span class="line"><span>  name: string;</span></span>
<span class="line"><span>  age: number;</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>type PersonKeys = keyof Person; // &#39;name&#39; | &#39;age&#39;</span></span>
<span class="line"><span>// 代码上面上面在 keyof 部分已经介绍过</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><h4 id="索引访问类型-indexed-access-types" tabindex="-1"><strong>索引访问类型（Indexed Access Types）</strong> <a class="header-anchor" href="#索引访问类型-indexed-access-types" aria-label="Permalink to &quot;**索引访问类型（Indexed Access Types）**&quot;">​</a></h4><p>索引访问类型，也称作查找类型（Lookup Types），使用 Type[KeyType] 的语法来获取一个类型的子类型。例如：</p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>type Age = Person[&#39;age&#39;]; // number</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><h4 id="索引签名-index-signatures" tabindex="-1"><strong>索引签名（Index Signatures）</strong> <a class="header-anchor" href="#索引签名-index-signatures" aria-label="Permalink to &quot;**索引签名（Index Signatures）**&quot;">​</a></h4><p>索引签名用于描述那些索引签名未知但类型已知的对象。它们允许你定义对象的索引类型和对应的返回值类型。有两种索引签名：字符串索引签名和数字索引签名。</p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>interface StringDictionary {</span></span>
<span class="line"><span>  [index: string]: string | number;</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>interface NumberDictionary {</span></span>
<span class="line"><span>  [index: number]: string;</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>const strDict: StringDictionary = {};</span></span>
<span class="line"><span>strDict[&#39;a&#39;] = &#39;foo&#39;; // Ok</span></span>
<span class="line"><span>strDict[&#39;b&#39;] = 42; // Ok</span></span>
<span class="line"><span></span></span>
<span class="line"><span>const numDict: NumberDictionary = {};</span></span>
<span class="line"><span>numDict[0] = &#39;bar&#39;; // Ok</span></span>
<span class="line"><span>// numDict[1] = 100;  // Error, Type &#39;number&#39; is not assignable to type &#39;string&#39;.</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br></div></div><h3 id="映射类型" tabindex="-1"><strong>映射类型</strong> <a class="header-anchor" href="#映射类型" aria-label="Permalink to &quot;**映射类型**&quot;">​</a></h3><p>映射类型（Mapped Types）是一种泛型类型，它能够根据旧的类型创建新的类型——它“映射”过一个已有的类型的属性，生成另一个类型。</p><p>映射类型通常与索引签名的语法结合使用，允许你指定一个属性键的集合并为这些键指定值的类型。基本的映射类型看起来像这样：</p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>type Keys = &#39;option1&#39; | &#39;option2&#39;;</span></span>
<span class="line"><span>type Flags = { [K in Keys]: boolean };</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p><img src="/jiang225638.github.io/assets/excellentArticle/2024-04-24/640-1713929828533-3.webp" alt="medium-zoom">Keys 是包含 &#39;option1&#39; 和 &#39;option2&#39; 的联合类型。Flags 是一个映射类型，它创建了一个新的类型，该类型有两个属性：option1 和 option2，它们的值类型都是 boolean。</p><p>映射类型的基本语法也就是这样：<code>{ [P in K]: T }</code></p><ul><li>P 是我们要遍历的属性名。</li><li>K 是属性名的集合，通常是字符串字面量的联合类型或 string/number/symbol 类型的子类型。</li><li>T 是属性的类型。</li></ul><p>所以他天然适合跟索引类型一起使用：</p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>interface Person {</span></span>
<span class="line"><span>  name: string;</span></span>
<span class="line"><span>  age: number;</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// Readonly 映射类型，使所有属性变为只读</span></span>
<span class="line"><span>type ReadonlyPerson = { readonly [P in keyof Person]: Person[P] };</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// Partial 映射类型，使所有属性变为可选</span></span>
<span class="line"><span>type PartialPerson = { [P in keyof Person]?: Person[P] };</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// Record 映射类型，创建一个对象类型，其属性键来自 K，属性值类型为 T</span></span>
<span class="line"><span>type ThreeStringProps = Record&lt;&#39;prop1&#39; | &#39;prop2&#39; | &#39;prop3&#39;, string&gt;;</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br></div></div><blockquote><p>❝</p><p>如上例子记住核心字段：<code>in</code>、<code>keyof</code>，在 TypeScript 类型编程中，非常普遍。</p></blockquote><h4 id="映射修饰符" tabindex="-1"><strong>映射修饰符</strong> <a class="header-anchor" href="#映射修饰符" aria-label="Permalink to &quot;**映射修饰符**&quot;">​</a></h4><p>映射类型还支持以下修饰符：</p><ul><li>readonly —— 使属性变为只读。</li><li>? —— 使属性变为可选。</li><li>-readonly —— 移除只读属性。</li><li>-? —— 移除可选属性。</li></ul><p>后买那我们实现 TypeScript 内置的工具类型的时候会使用到。</p><h3 id="条件类型" tabindex="-1"><strong>条件类型</strong> <a class="header-anchor" href="#条件类型" aria-label="Permalink to &quot;**条件类型**&quot;">​</a></h3><p>条件类型让类型具有了判断的能力，它们在类型系统中引入了一种选择机制，允许根据条件定义类型。</p><p>条件类型跟 JavaScript 中的三元表达式近乎一样，我们也可以理解为这是 TypeScript 类型编程中的 ifElse</p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>T extends U ? X : Y</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><p>这里的 T 是一个类型变量，U 是一个检查类型（你可以理解成，如果成如果 T 类型可以赋值给 U），X 和 Y 是两种可能的类型。如果 T 扩展或等于 U，则条件类型的结果是 X，否则是 Y。</p><p>举个栗子：</p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>type IsString&lt;T&gt; = T extends string ? &#39;yes&#39; : &#39;no&#39;;</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><p>在这个例子中，IsString 是一个条件类型，它检查 T 是否可被赋值给 string。如果可以，它的结果类型将是字面量类型 &quot;yes&quot;，否则是 &quot;no&quot;。</p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>type T1 = IsString&lt;string&gt;; // &quot;yes&quot;</span></span>
<span class="line"><span>type T2 = IsString&lt;number&gt;; // &quot;no&quot;</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><h4 id="infer-关键字" tabindex="-1"><strong>infer 关键字</strong> <a class="header-anchor" href="#infer-关键字" aria-label="Permalink to &quot;**infer 关键字**&quot;">​</a></h4><p>infer 关键字是在条件类型中使用的，它允许你在条件的真分支中声明一个类型变量，然后可以在该分支中使用这个类型。说白了就是做变量类型提取的。</p><p><strong>从函数类型中提取返回类型</strong></p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>type ReturnType&lt;T&gt; = T extends (...args: any[]) =&gt; infer R ? R : never;</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><p>在这个 ReturnType 类型定义中，T 是一个泛型参数，它被期望是一个函数类型。这个条件类型检查 T 是否可以赋值给 (...args: any[]) =&gt; infer R 这样的函数类型。如果可以，TypeScript 将会推断这个函数的返回类型，并将其捕获到 R 中。然后 ReturnType就会被解析为 R，否则解析为 any。</p><p><strong>从 Promise 中提取解决的类型</strong></p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>type UnpackPromise&lt;T&gt; = T extends Promise&lt;infer U&gt; ? U : T;</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><p><strong>从数组类型中提取元素类型</strong></p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>type ElementType&lt;T&gt; = T extends (infer U)[] ? U : T;</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><p>在这个例子中，ElementType 类型检查 T 是否是一个数组类型。如果是，它使用 infer U 来捕获数组的元素类型，然后将 ElementType解析为该元素类型。如果 T 不是数组类型，那么结果类型就是 T 自己。</p><h4 id="分布式条件类型" tabindex="-1"><strong>分布式条件类型</strong> <a class="header-anchor" href="#分布式条件类型" aria-label="Permalink to &quot;**分布式条件类型**&quot;">​</a></h4><p>在泛型上下文中，条件类型被认为是“分布式”的，当 T 是一个联合类型时，条件类型会被应用于联合类型中的每一个成员，并最后组合成一个联合类型。</p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>type ToArray&lt;T&gt; = T extends any ? T[] : never;</span></span>
<span class="line"><span>type StrOrNumArray = ToArray&lt;string | number&gt;;</span></span>
<span class="line"><span>// type StrOrNumArray = string[] | number[]</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>这里，ToArray 条件类型检查 T 是否可被赋值给 any，这个总是为真，所以它将 T 转换为一个数组 T[]。对于 StrOrNumArray，由于 T 是 string | number，ToArray 类型将分别应用于 string 和 number，结果是 string[] | number[]。</p><p>条件类型在 TypeScript 的类型定义中<strong>非常有用</strong>，尤其是在创建通用的工具类型或者处理库的类型定义时。例如，TypeScript 标准库中就包含了很多内置的条件类型，如 <code>Exclude</code>, <code>Extract</code>, <code>ReturnType</code>, <code>InstanceType</code> 等。</p><p>条件类型可以用于创建复杂的类型推断，类型转换，以及根据输入类型动态选择输出类型的类型。这也是 TypeScript 类型编程中非常核心的功能之一。</p><h3 id="模板字面量类型" tabindex="-1"><strong>模板字面量类型</strong> <a class="header-anchor" href="#模板字面量类型" aria-label="Permalink to &quot;**模板字面量类型**&quot;">​</a></h3><p>模板字面量类型（Template Literal Types）是 TypeScript4.1 引入的新的类型。说白了是一种字符串类型的补充，可以构造出几乎无限多的字符串类型，这使得你能够更精确地描述字符串的形状和模式。</p><p>模板字面量类型使用反引号（`）来定义，就像 JavaScript 中的模板字符串一样。类型中可以包含字符串文字部分和插值部分，插值部分通过 ${} 包裹一个类型。</p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>type World = &#39;world&#39;;</span></span>
<span class="line"><span>type Greeting = `hello ${World}`;</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>在这个例子中，Greeting 的类型是 &quot;hello world&quot; 这个具体的字符串。<img src="/jiang225638.github.io/assets/excellentArticle/2024-04-24/640-1713929828533-4.webp" alt="medium-zoom"></p><p>客官稍安勿躁。。我还有花活。。。</p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>type EmailLocaleIDs = `welcome_email_${&#39;en&#39; | &#39;es&#39; | &#39;fr&#39;}`;</span></span>
<span class="line"><span>type FooterLocaleIDs = `footer_${&#39;en&#39; | &#39;es&#39; | &#39;fr&#39;}`;</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>在这里，EmailLocaleIDs 类型能够表示 &quot;welcome_email_en&quot;、&quot;welcome_email_es&quot; 或 &quot;welcome_email_fr&quot; 中的任何一个。FooterLocaleIDs 也类似。</p><p><strong>分布式字符串类型有木有！</strong></p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>type LocaleMessageIDs = `${&#39;welcome_email&#39; | &#39;footer&#39;}_${&#39;en&#39; | &#39;es&#39; | &#39;fr&#39;}`;</span></span>
<span class="line"><span>// LocaleMessageIDs 类型会包含每种可能的组合，如 &quot;welcome_email_en&quot;、&quot;footer_fr&quot; 等。</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><h4 id="映射类型与模板字面量类型" tabindex="-1"><strong>映射类型与模板字面量类型</strong> <a class="header-anchor" href="#映射类型与模板字面量类型" aria-label="Permalink to &quot;**映射类型与模板字面量类型**&quot;">​</a></h4><p>模板字面量类型可以与映射类型相结合，以便在对象键或其他映射类型上构造复杂的类型。</p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>type PropEventSource&lt;Type&gt; = {</span></span>
<span class="line"><span>  on(</span></span>
<span class="line"><span>    eventName: `${string &amp; keyof Type}Changed`,</span></span>
<span class="line"><span>    callback: (newValue: any) =&gt; void</span></span>
<span class="line"><span>  ): void;</span></span>
<span class="line"><span>};</span></span>
<span class="line"><span></span></span>
<span class="line"><span>declare function makeWatchedObject&lt;T&gt;(obj: T): T &amp; PropEventSource&lt;T&gt;;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>const person = makeWatchedObject({</span></span>
<span class="line"><span>  firstName: &#39;Homer&#39;,</span></span>
<span class="line"><span>  age: 42,</span></span>
<span class="line"><span>  location: &#39;Springfield&#39;,</span></span>
<span class="line"><span>});</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// 使用它</span></span>
<span class="line"><span>person.on(&#39;firstNameChanged&#39;, (newName) =&gt; {</span></span>
<span class="line"><span>  console.log(`new name is ${newName.toUpperCase()}`);</span></span>
<span class="line"><span>});</span></span>
<span class="line"><span></span></span>
<span class="line"><span>person.on(&#39;ageChanged&#39;, (newAge) =&gt; {</span></span>
<span class="line"><span>  if (newAge &lt; 0) {</span></span>
<span class="line"><span>    console.log(&#39;warning! negative age&#39;);</span></span>
<span class="line"><span>  }</span></span>
<span class="line"><span>});</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br></div></div><p>在这个例子中，PropEventSource 类型使用模板字面量类型创建了一个监听事件的类型，其事件名是基于对象的键和字符串 &#39;Changed&#39; 的组合。</p><p>可以见得，并非“就这”，还很强大，模板字符串使得类型定义可以精确到模板字符串的级别。这对于需要强类型约束的字符串模式，如类、样式名、路由路径等场景非常有帮助，并且在构建类型安全的 API 时它们也发挥着重要作用。</p><h2 id="内置类型编程实现" tabindex="-1"><strong>内置类型编程实现</strong> <a class="header-anchor" href="#内置类型编程实现" aria-label="Permalink to &quot;**内置类型编程实现**&quot;">​</a></h2><blockquote><p>❝</p><p>很多内置的类型工具我们在上面都举例过了，这里也罗列（常用的）出来做个汇总</p></blockquote><h3 id="partial" tabindex="-1"><strong>Partial</strong> <a class="header-anchor" href="#partial" aria-label="Permalink to &quot;**Partial**&quot;">​</a></h3><p>将类型 T 的所有属性变为可选（optional）。</p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>type Partial&lt;T&gt; = {</span></span>
<span class="line"><span>  [P in keyof T]?: T[P];</span></span>
<span class="line"><span>};</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><h3 id="required" tabindex="-1"><strong>Required</strong> <a class="header-anchor" href="#required" aria-label="Permalink to &quot;**Required**&quot;">​</a></h3><p>将类型 T 的所有属性变为必需的（non-optional）。</p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>type Required&lt;T&gt; = {</span></span>
<span class="line"><span>  [P in keyof T]-?: T[P];</span></span>
<span class="line"><span>};</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><h3 id="readonly" tabindex="-1"><strong>Readonly</strong> <a class="header-anchor" href="#readonly" aria-label="Permalink to &quot;**Readonly**&quot;">​</a></h3><p>将类型 T 的所有属性设置为只读，这样就无法修改这些属性。</p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>type Readonly&lt;T&gt; = {</span></span>
<span class="line"><span>  readonly [P in keyof T]: T[P];</span></span>
<span class="line"><span>};</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><h3 id="record-k-t" tabindex="-1"><strong>Record&lt;K, T&gt;</strong> <a class="header-anchor" href="#record-k-t" aria-label="Permalink to &quot;**Record&lt;K, T&gt;**&quot;">​</a></h3><p>创建一个类型，其属性键为 K，属性值为 T。</p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>type Record&lt;K extends keyof any, T&gt; = {</span></span>
<span class="line"><span>  [P in K]: T;</span></span>
<span class="line"><span>};</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><h3 id="pick-t-k" tabindex="-1"><strong>Pick&lt;T, K&gt;</strong> <a class="header-anchor" href="#pick-t-k" aria-label="Permalink to &quot;**Pick&lt;T, K&gt;**&quot;">​</a></h3><p>从类型 T 中选取一组属性 K（K 必须是 T 的属性）来构造类型。</p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>type Pick&lt;T, K extends keyof T&gt; = {</span></span>
<span class="line"><span>  [P in K]: T[P];</span></span>
<span class="line"><span>};</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><h3 id="exclude-t-u" tabindex="-1"><strong>Exclude&lt;T, U&gt;</strong> <a class="header-anchor" href="#exclude-t-u" aria-label="Permalink to &quot;**Exclude&lt;T, U&gt;**&quot;">​</a></h3><p>从类型 T 中排除那些可以赋值给 U 的类型。</p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>type Exclude&lt;T, U&gt; = T extends U ? never : T;</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><h3 id="omit-t-k" tabindex="-1"><strong>Omit&lt;T, K&gt;</strong> <a class="header-anchor" href="#omit-t-k" aria-label="Permalink to &quot;**Omit&lt;T, K&gt;**&quot;">​</a></h3><p>从类型 T 中排除一组属性 K 后的类型。</p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>type Omit&lt;T, K extends keyof T&gt; = Pick&lt;T, Exclude&lt;keyof T, K&gt;&gt;;</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><h3 id="extract-t-u" tabindex="-1"><strong>Extract&lt;T, U&gt;</strong> <a class="header-anchor" href="#extract-t-u" aria-label="Permalink to &quot;**Extract&lt;T, U&gt;**&quot;">​</a></h3><p>从类型 T 中提取那些可以赋值给 U 的类型</p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>type Extract&lt;T, U&gt; = T extends U ? T : never;</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><h3 id="nonnullable" tabindex="-1"><strong>NonNullable</strong> <a class="header-anchor" href="#nonnullable" aria-label="Permalink to &quot;**NonNullable**&quot;">​</a></h3><p>从类型 T 中排除 null 和 undefined。</p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>type NonNullable&lt;T&gt; = T extends null | undefined ? never : T;</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><h3 id="returntype" tabindex="-1"><strong>ReturnType</strong> <a class="header-anchor" href="#returntype" aria-label="Permalink to &quot;**ReturnType**&quot;">​</a></h3><p>获取函数类型 T 的返回类型。</p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>type ReturnType&lt;T&gt; = T extends (...args: any[]) =&gt; infer R ? R : any;</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><h3 id="instancetype" tabindex="-1"><strong>InstanceType</strong> <a class="header-anchor" href="#instancetype" aria-label="Permalink to &quot;**InstanceType**&quot;">​</a></h3><p>获取构造函数类型 T 的实例类型。</p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>type InstanceType&lt;T&gt; = T extends new (...args: any[]) =&gt; infer R ? R : any;</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><h3 id="parameters" tabindex="-1"><strong>Parameters</strong> <a class="header-anchor" href="#parameters" aria-label="Permalink to &quot;**Parameters**&quot;">​</a></h3><p>获取函数类型 T 的参数类型作为一个元组。</p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>type Parameters&lt;T&gt; = T extends (...args: infer P) =&gt; any ? P : any;</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><h3 id="constructorparameters" tabindex="-1"><strong>ConstructorParameters</strong> <a class="header-anchor" href="#constructorparameters" aria-label="Permalink to &quot;**ConstructorParameters**&quot;">​</a></h3><p>获取构造函数类型 T 的参数类型作为一个元组。</p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>type ConstructorParameters&lt;T&gt; = T extends new (...args: infer P) =&gt; any</span></span>
<span class="line"><span>  ? P</span></span>
<span class="line"><span>  : any;</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><h2 id="类型编程的实际应用" tabindex="-1"><strong>类型编程的实际应用</strong> <a class="header-anchor" href="#类型编程的实际应用" aria-label="Permalink to &quot;**类型编程的实际应用**&quot;">​</a></h2><h3 id="自定义-render" tabindex="-1"><strong>自定义 render</strong> <a class="header-anchor" href="#自定义-render" aria-label="Permalink to &quot;**自定义 render**&quot;">​</a></h3><p>需求：编写一个 render 方法，传入一个组件，以及该组件对应的 Props，需要约束传入的组件必须带有 ref 或者制定一个 dom 节点（属性约束）</p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>const CUS_DOM_OPT_PANEL_ID = &#39;__@custom_dom_opt_panel_id__&#39;;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>interface WithRef {</span></span>
<span class="line"><span>  domRef: RefObject&lt;HTMLElement&gt;;</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>interface WithDom {</span></span>
<span class="line"><span>  targetNode: HTMLElement;</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>type TExtends = WithRef | WithDom;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>function customRender&lt;P extends TExtends&gt;(Comp: Rax.FC&lt;P&gt;, props: P, cusWrapId?: string) {</span></span>
<span class="line"><span>  let parentDiv: HTMLDivElement = getElementById(cusWrapId || CUS_DOM_OPT_PANEL_ID);</span></span>
<span class="line"><span>  if (parentDiv) {</span></span>
<span class="line"><span>    parentDiv.remove();</span></span>
<span class="line"><span>  }</span></span>
<span class="line"><span>  parentDiv = document.createElement(&#39;div&#39;);</span></span>
<span class="line"><span>  parentDiv.style.position = &#39;absolute&#39;;</span></span>
<span class="line"><span>  parentDiv.setAttribute(&#39;id&#39;, CUS_DOM_OPT_PANEL_ID);</span></span>
<span class="line"><span>  document.body.appendChild(parentDiv);</span></span>
<span class="line"><span>  // @ts-ignore</span></span>
<span class="line"><span>  render(&lt;Comp {...props} /&gt;, parentDiv, { driver: DriverUniversal });</span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br></div></div><h3 id="自定义类型" tabindex="-1"><strong>自定义类型</strong> <a class="header-anchor" href="#自定义类型" aria-label="Permalink to &quot;**自定义类型**&quot;">​</a></h3><p>本案例来自神光的《TypeScript 类型体操通关秘籍》小册</p><p><img src="/jiang225638.github.io/assets/excellentArticle/2024-04-24/640-1713929828533-5.webp" alt="medium-zoom"></p><p>需求非常简单，首先我们不可能枚举出每一列的情况，就是求对象中只有一个字段可以是 &#39;desc&#39; | &#39;asc&#39;，其他字段都必须是 false。</p><p>神光在小册中给出的解决方案非常的不错，感兴趣的可以去看看，这里我们换个思路</p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>type SortOrder = &quot;desc&quot; | &quot;asc&quot;;</span></span>
<span class="line"><span>type MyTableSort = &quot;a&quot; | &quot;b&quot; | &quot;c&quot;;</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>首先定义出来我们要的一些字段</p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>type ExclusiveSort&lt;T extends string, K extends T&gt; = {</span></span>
<span class="line"><span>  [P in T]: P extends K ? SortOrder : false;</span></span>
<span class="line"><span>};</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>ExclusiveSort 是一个映射类型，它用于创建一个对象类型，其中只有一个属性（K）可以被设置为 SortOrder 类型（&quot;desc&quot; 或 &quot;asc&quot;），而所有其他属性都必须是 false。这里的 T extends string 约束表明 T 必须是基于字符串的类型，具体为 MyTableSort 联合类型。K extends T 表示 K 是 T 联合类型中的一个成员。在映射类型的定义中，[P in T] 部分是一个类型变量 P 遍历 T 联合类型中的每一个成员。对于每个成员，我们使用了一个条件类型 P extends K ? SortOrder : false。这里的含义是，如果 P 等于当前的 K（即 P 正在被遍历为当前可排序的属性），则该属性的类型是 SortOrder；否则，属性的类型必须是 false。</p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>type Sortable&lt;T extends string&gt; = {</span></span>
<span class="line"><span>  [K in T]: ExclusiveSort&lt;T, K&gt;;</span></span>
<span class="line"><span>}[T];</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>在映射类型 [K in T]: ExclusiveSort&lt;T, K&gt; 中，我们对于 T 类型的每个字段 K，都创建了一个 ExclusiveSort&lt;T, K&gt; 类型。这意味着对于 T 中的每个字段，我们都会有一个对象类型，其中该字段是 SortOrder 类型，其他字段都是 false。</p><p>然后，通过在这个映射类型后面加上 [T]，我们得到一个从映射类型中提取所有成员类型并组成一个联合类型的操作。这个联合类型表示所有可能的排序状态组合。</p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>type ValidSort = Sortable&lt;MyTableSort&gt;;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>let validSortA: ValidSort = { a: &#39;asc&#39;, b: false, c: false }; // OK</span></span>
<span class="line"><span>let validSortB: ValidSort = { a: false, b: &#39;desc&#39;, c: false }; // OK</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>至此就完成了上面的需要的类型约束。</p><blockquote><p>❝</p><p>解法不止一种个，小册中的写法</p></blockquote><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>type GenerateType&lt;Keys extends string&gt; = {</span></span>
<span class="line"><span>    [Key in Keys]: {</span></span>
<span class="line"><span>        [Key2 in Key]: &#39;desc&#39; | &#39;asc&#39;</span></span>
<span class="line"><span>    } &amp; {</span></span>
<span class="line"><span>        [Key3 in Exclude&lt;Keys, Key&gt;]: false</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span>}[Keys]</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><h2 id="type-challenges" tabindex="-1"><strong>type-challenges</strong> <a class="header-anchor" href="#type-challenges" aria-label="Permalink to &quot;**type-challenges**&quot;">​</a></h2><p>类型变成其实也需要一种变成思维的养成，甚至比我们常规的编码更加抽象一些。但是其大致章法也就这些，所以如上你掌握了基础知识，可以参与下github 上的type-challenges 挑战，实操几道题后，你就掌握了类型编程的大致思路。基本上medium 级别的的就已经能应对 99.9%日常需求了~</p><h2 id="参考文档" tabindex="-1"><strong>参考文档</strong> <a class="header-anchor" href="#参考文档" aria-label="Permalink to &quot;**参考文档**&quot;">​</a></h2><ul><li>TypeScript 的另一面：类型编程</li><li>冴羽 Ts 网站</li><li>《TypeScript 类型体操通关秘籍》</li><li>type-challenges</li></ul></div></div></main><footer class="VPDocFooter" data-v-382fc3ef data-v-4eab72ca><!--[--><!--]--><div class="edit-info" data-v-4eab72ca><!----><div class="last-updated" data-v-4eab72ca><p class="VPLastUpdated" data-v-4eab72ca data-v-fc38ec77>上次更新: <time datetime="2024-05-23T07:24:20.000Z" data-v-fc38ec77></time></p></div></div><nav class="prev-next" aria-labelledby="doc-footer-aria-label" data-v-4eab72ca><span class="visually-hidden" id="doc-footer-aria-label" data-v-4eab72ca>Pager</span><div class="pager" data-v-4eab72ca><a class="VPLink link pager-link prev" href="/jiang225638.github.io/excellentArticle/2024-04-23/" data-v-4eab72ca><!--[--><span class="desc" data-v-4eab72ca>上一篇</span><span class="title" data-v-4eab72ca>TypeScript很麻烦💔，不想使用！</span><!--]--></a></div><div class="pager" data-v-4eab72ca><a class="VPLink link pager-link next" href="/jiang225638.github.io/excellentArticle/2024-05-06/" data-v-4eab72ca><!--[--><span class="desc" data-v-4eab72ca>下一篇</span><span class="title" data-v-4eab72ca>前端视频人像实时捕获技术,超干货!!!</span><!--]--></a></div></nav></footer><!--[--><!--]--></div></div></div><!--[--><!--]--></div></div><!----><!--[--><!--]--></div></div>
    <script>window.__VP_HASH_MAP__=JSON.parse("{\"rotelearning_vue_index.md\":\"DmsrwUHq\",\"rotelearning_react_index.md\":\"0NYVtg2o\",\"excellentarticle_2024-05-17_index.md\":\"DtV3M8u-\",\"react_index.md\":\"DH8UJak8\",\"nav_index.md\":\"BFaswMsX\",\"nestjs_base_index.md\":\"p52CTR9Z\",\"excellentarticle_2024-04-11_index.md\":\"BMPNvjeH\",\"excellentarticle_2024-06-14_index.md\":\"BTaj62Zu\",\"excellentarticle_2024-05-15_index.md\":\"CweZaCki\",\"rotelearning_javascript_index.md\":\"CQZs-kXq\",\"excellentarticle_2024-05-23_index.md\":\"whLSKZHA\",\"test.md\":\"BiYJQ87O\",\"rotelearning_index.md\":\"Do0AjfFl\",\"excellentarticle_2024-05-07_index.md\":\"BJCOY0NM\",\"dailyrecord_index.md\":\"DbROq6Ds\",\"js_2024-04-19_index.md\":\"DCRH_tIF\",\"vue_index.md\":\"On5tHZgQ\",\"nestjs_providers_index.md\":\"DLOrL9-i\",\"nestjs_index.md\":\"LRt04RQk\",\"js_index.md\":\"CWUcsRnv\",\"excellentarticle_index.md\":\"5nfSK3ZN\",\"excellentarticle_2024-06-21_index.md\":\"BpT_X4nF\",\"ts_index.md\":\"CYzRKbzZ\",\"thewayforward_ihaveroadbythailand_index.md\":\"CnRN_RcK\",\"excellentarticle_2024-05-31_index.md\":\"B8poAXYO\",\"excellentarticle_2024-06-13_index.md\":\"BrLDW2C6\",\"excellentarticle_2024-06-07_index.md\":\"B3qk3Tog\",\"excellentarticle_2024-04-17_index.md\":\"DhAF6deI\",\"excellentarticle_2024-05-30_index.md\":\"DzgAmMvF\",\"excellentarticle_2024-04-18_index.md\":\"mVBddGnR\",\"excellentarticle_2024-04-15_index.md\":\"CX-2pe0a\",\"index.md\":\"DJ9-bna4\",\"excellentarticle_2024-04-24_index.md\":\"DX_eAfBy\",\"html_index.md\":\"D98HKj-F\",\"excellentarticle_2024-05-06_index.md\":\"B7lAcN0a\",\"test_index.md\":\"9hh9CJMJ\",\"nestjs_proconfig_index.md\":\"Czq5A7M0\",\"css_index.md\":\"BYoc4xFs\",\"excellentarticle_2024-04-12_index.md\":\"DBgKkYDG\",\"excellentarticle_2024-04-16_index.md\":\"Di0kEJTK\",\"nestjs_prisma_index.md\":\"Cz3bbwMD\",\"workexperience_index.md\":\"DSNIno2Y\",\"nestjs_module_index.md\":\"CUYTtCp0\",\"thewayforward_index.md\":\"y22zwq6Z\",\"excellentarticle_2024-04-23_index.md\":\"Bs9AKJ14\",\"js_2024-05-23_index.md\":\"ClkMiBAZ\"}");window.__VP_SITE_DATA__=JSON.parse("{\"lang\":\"zh-CN\",\"dir\":\"ltr\",\"title\":\"想躺不敢躺\",\"description\":\"啥都不会，只想躺平，看看小说，听听音乐，晒晒太阳\",\"base\":\"/jiang225638.github.io/\",\"head\":[],\"router\":{\"prefetchLinks\":true},\"appearance\":true,\"themeConfig\":{\"i18nRouting\":false,\"logo\":\"/logo1.gif\",\"nav\":[{\"text\":\"看穿尘世\",\"items\":[{\"text\":\"js\",\"link\":\"/js/\"},{\"text\":\"TS\",\"link\":\"/ts/\"},{\"text\":\"css\",\"link\":\"/css/\"},{\"text\":\"html\",\"link\":\"/html\"},{\"text\":\"vue\",\"link\":\"/vue/\"},{\"text\":\"react\",\"link\":\"/react/\"},{\"text\":\"nestjs\",\"link\":\"/nestjs/base/\"}]},{\"text\":\"阅尽繁华\",\"items\":[{\"text\":\"读过的精彩\",\"link\":\"/excellentArticle/\"}]}],\"sidebar\":{\"/excellentArticle/\":[{\"text\":\"每日阅读\",\"items\":[{\"text\":\"前端常见的安全攻击方式、原理、以及如何防护！\",\"link\":\"/excellentArticle/2024-04-11/\"},{\"text\":\"为什么需要缓存\",\"link\":\"/excellentArticle/2024-04-12/\"},{\"text\":\"面试官：Vue3中什么是Reactive的懒响应性？\",\"link\":\"/excellentArticle/2024-04-15/\"},{\"text\":\"搞懂 Vue3 中的各种 ref: toRef,toRefs,isRef,unref...\",\"link\":\"/excellentArticle/2024-04-16/\"},{\"text\":\"基于nginx+ffmpeg+vue3+TypeScript在网页上显示监控的实时画面\",\"link\":\"/excellentArticle/2024-04-17/\"},{\"text\":\"面试官：只知道v-model是modelValue语法糖，那你可以走了\",\"link\":\"/excellentArticle/2024-04-18/\"},{\"text\":\"TypeScript很麻烦💔，不想使用！\",\"link\":\"/excellentArticle/2024-04-23/\"},{\"text\":\"一文掌握 TS 高级类型编程\",\"link\":\"/excellentArticle/2024-04-24/\"},{\"text\":\"前端视频人像实时捕获技术,超干货!!!\",\"link\":\"/excellentArticle/2024-05-06/\"},{\"text\":\"5分钟带你了解【前端装饰器】，“高大上”的“基础知识”\",\"link\":\"/excellentArticle/2024-05-07/\"},{\"text\":\"开发阶段！跨域问题多种解决方案的精华总结\",\"link\":\"/excellentArticle/2024-05-15/\"},{\"text\":\"ES7、ES8、ES9、ES10、ES11、ES12都增加了哪些新特性？\",\"link\":\"/excellentArticle/2024-05-17/\"},{\"text\":\"前端需要知道的缓存知识总结\",\"link\":\"/excellentArticle/2024-05-23/\"},{\"text\":\"领导被我的花式console.log吸引了！直接写入公司公共库！\",\"link\":\"/excellentArticle/2024-05-30/\"},{\"text\":\"赶快收藏！全网最佳websocket封装：完美支持断网重连、自动心跳！\",\"link\":\"/excellentArticle/2024-05-31/\"},{\"text\":\"CSS 动画从入门到高手!\",\"link\":\"/excellentArticle/2024-06-07/\"},{\"text\":\"1000个判断条件难道要写了1000个 if ? 一文教你如何实现分支优化\",\"link\":\"/excellentArticle/2024-06-13/\"},{\"text\":\"在 web 地图上的踩坑指南\",\"link\":\"/excellentArticle/2024-06-14/\"},{\"text\":\"一个reduce还能玩出这么多花样儿？中高级前端都知道的reduce函数高级用法\",\"link\":\"/excellentArticle/2024-06-21/\"}]}],\"/roteLearning/\":[{\"text\":\"需要死记硬背的八股\",\"items\":[{\"text\":\"一丢丢vue面试题\",\"link\":\"/roteLearning/vue/\"},{\"text\":\"复习复习44个react知识点\",\"link\":\"/roteLearning/react/\"},{\"text\":\"进阶进阶！复习50个JavaScript「进阶」知识点\",\"link\":\"/roteLearning/javaScript/\"}]}],\"/js/\":[{\"text\":\"积累\",\"items\":[{\"text\":\"提高开发效率的10个JavaScript技巧\",\"link\":\"/js/2024-04-19/\"},{\"text\":\"万字总结 JS 数据结构与常用的算法\",\"link\":\"/js/2024-05-23/\"}]}],\"/nestjs/\":[{\"text\":\"原文请上后盾人官网查看www.houdunren.com\",\"items\":[{\"text\":\"基础知识\",\"link\":\"/nestjs/base/\"},{\"text\":\"提供者\",\"link\":\"/nestjs/providers/\"},{\"text\":\"模块\",\"link\":\"/nestjs/module/\"},{\"text\":\"项目配置\",\"link\":\"/nestjs/proConfig/\"},{\"text\":\"prisma\",\"link\":\"/nestjs/prisma/\"}]}],\"/theWayForward/\":[{\"text\":\"原文请上后盾人官网查看www.houdunren.com\",\"items\":[{\"text\":\"基础知识\",\"link\":\"/theWayForward/iHaveRoadbyThailand/\"}]}]},\"outline\":{\"level\":\"deep\",\"label\":\"本页目录\"},\"darkModeSwitchLabel\":\"外观\",\"returnToTopLabel\":\"返回顶部\",\"lastUpdatedText\":\"上次更新\",\"docFooter\":{\"prev\":\"上一篇\",\"next\":\"下一篇\"}},\"locales\":{},\"scrollOffset\":134,\"cleanUrls\":true}");</script>
    
  </body>
</html>