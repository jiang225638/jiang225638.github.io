import{_ as e,c as n,o as s,a5 as a}from"./chunks/framework.BXMMEvbx.js";const o="/jiang225638.github.io/assets/excellentArticle/2024-04-18/0.jpeg",p="/jiang225638.github.io/assets/excellentArticle/2024-04-18/640-1713444830906-136.png",c="/jiang225638.github.io/assets/excellentArticle/2024-04-18/640-1713444830906-137.png",d="/jiang225638.github.io/assets/excellentArticle/2024-04-18/640-1713444830906-138.png",l="/jiang225638.github.io/assets/excellentArticle/2024-04-18/640-1713444830906-139.png",r="/jiang225638.github.io/assets/excellentArticle/2024-04-18/640-1713444830906-140.png",t="/jiang225638.github.io/assets/excellentArticle/2024-04-18/640-1713444830906-141.png",i="/jiang225638.github.io/assets/excellentArticle/2024-04-18/640-1713444830906-142.png",u="/jiang225638.github.io/assets/excellentArticle/2024-04-18/640-1713444830906-143.png",m="/jiang225638.github.io/assets/excellentArticle/2024-04-18/640-1713444830906-144.png",N=JSON.parse('{"title":"面试官：只知道v-model是modelValue语法糖，那你可以走了","description":"","frontmatter":{},"headers":[],"relativePath":"excellentArticle/2024-04-18/index.md","filePath":"excellentArticle/2024-04-18/index.md","lastUpdated":1713520108000}'),b={name:"excellentArticle/2024-04-18/index.md"},v=a('<h1 id="面试官-只知道v-model是modelvalue语法糖-那你可以走了" tabindex="-1">面试官：只知道v-model是modelValue语法糖，那你可以走了 <a class="header-anchor" href="#面试官-只知道v-model是modelvalue语法糖-那你可以走了" aria-label="Permalink to &quot;面试官：只知道v-model是modelValue语法糖，那你可以走了&quot;">​</a></h1><p><img src="'+o+'" alt="img"></p><h2 id="通过debug的方式带你看vue源码" tabindex="-1">通过debug的方式带你看vue源码 <a class="header-anchor" href="#通过debug的方式带你看vue源码" aria-label="Permalink to &quot;通过debug的方式带你看vue源码&quot;">​</a></h2><p><strong>前言</strong></p><p>我们每天都在用<code>v-model</code>，并且大家都知道在vue3中<code>v-model</code>是<code>:modelValue</code>和<code>@update:modelValue</code>的语法糖。那你知道<code>v-model</code>指令是如何变成组件上的<code>modelValue</code>属性和<code>@update:modelValue</code>事件呢？将<code>v-model</code>指令转换为<code>modelValue</code>属性和<code>@update:modelValue</code>事件这一过程是在编译时还是运行时进行的呢？</p><h1 id="先说结论" tabindex="-1"><strong>先说结论</strong> <a class="header-anchor" href="#先说结论" aria-label="Permalink to &quot;**先说结论**&quot;">​</a></h1><p>下面这个是我画的处理<code>v-model</code>指令的完整流程图：</p><p><img src="'+p+'" alt="medium-zoom"></p><p>首先会调用<code>parse</code>函数将template模块中的代码转换为AST抽象语法树，此时使用<code>v-model</code>的node节点的props属性中还是<code>v-model</code>。接着会调用<code>transform</code>函数，经过<code>transform</code>函数处理后在<code>node</code>节点中多了一个<code>codegenNode</code>属性。在<code>codegenNode</code>属性中我们看到没有<code>v-model</code>指令，取而代之的是<code>modelValue</code>和<code>onUpdate:modelValue</code>属性。经过<code>transform</code>函数处理后已经将<code>v-model</code>指令编译为<code>modelValue</code>和<code>onUpdate:modelValue</code>属性，此时还是AST抽象语法树。所以接下来就是调用<code>generate</code>函数将AST抽象语法树转换为<code>render</code>函数，到此为止编译时做的事情已经做完了，<strong>经过编译时的处理<code>v-model</code>指令已经变成了<code>modelValue</code>和<code>onUpdate:modelValue</code>属性。</strong></p><p>接着就是运行时阶段，在浏览器中执行<code>render</code>函数生成虚拟DOM。在生成虚拟DOM的过程中由于props属性中有<code>modelValue</code>和<code>onUpdate:modelValue</code>属性，所以就会给组件对象加上<code>modelValue</code>属性和<code>@update:modelValue</code>事件。最后就是调用<code>mount</code>方法将虚拟DOM转换为真实DOM。<strong>所以<code>v-model</code>指令转换为<code>modelValue</code>属性和<code>@update:modelValue</code>事件这一过程是在编译时进行的。</strong></p><h1 id="什么是编译时-什么是运行时" tabindex="-1"><strong>什么是编译时？什么是运行时？</strong> <a class="header-anchor" href="#什么是编译时-什么是运行时" aria-label="Permalink to &quot;**什么是编译时？什么是运行时？**&quot;">​</a></h1><p>vue是一个编译时+运行时一起工作的框架，之前有小伙伴私信我说自己傻傻分不清楚在vue中什么时候是编译时，什么时候是运行时。要回答小伙伴的这个问题我们要从一个vue文件是如何渲染到浏览器窗口中说起。</p><p>我们的vue代码一般都是写在后缀名为vue的文件上，显然浏览器是不认识vue文件的，浏览器只认识html、css、jss等文件类型。所以第一步就是通过webpack或者vite将一个vue文件编译为一个包含<code>render</code>函数的js文件，在这一步中代码的执行环境是在nodejs中进行，也就是我们所说的编译时。相比浏览器端来说能够拿到的权限更多，也能做更多的事情。后面就是执行<code>render</code>函数生成虚拟DOM，再调用浏览器的DOM API根据虚拟DOM生成真实DOM挂载到浏览器上。在第一步后面的这些过程中代码执行环境都是在浏览器中，也就是我们所说的运行时。在客户端渲染的场景下，一句话总结就是：代码跑在nodejs端的时候就是编译时，代码跑在浏览器端的时候就是运行时。</p><p><img src="'+c+`" alt="medium-zoom"></p><h1 id="举个例子" tabindex="-1"><strong>举个例子</strong> <a class="header-anchor" href="#举个例子" aria-label="Permalink to &quot;**举个例子**&quot;">​</a></h1><p>我们来看一个<code>v-model</code>的例子，父组件<code>index.vue</code>的代码如下：</p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>&lt;template&gt;</span></span>
<span class="line"><span>  &lt;CommonChild v-model=&quot;inputValue&quot; /&gt;</span></span>
<span class="line"><span>  &lt;p&gt;input value is: {{ inputValue }}&lt;/p&gt;</span></span>
<span class="line"><span>&lt;/template&gt;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>&lt;script setup lang=&quot;ts&quot;&gt;</span></span>
<span class="line"><span>import { ref } from &quot;vue&quot;;</span></span>
<span class="line"><span>import CommonChild from &quot;./child.vue&quot;;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>const inputValue = ref();</span></span>
<span class="line"><span>&lt;/script&gt;</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><p>我们上面是一个很简单的<code>v-model</code>的例子，在<code>CommonChild</code>子组件上使用<code>v-model</code>绑定一个叫<code>inputValue</code>的ref变量，然后将这个<code>inputValue</code>变量渲染到p标签上面。</p><p>前面我们已经讲过了客户端渲染的场景下，在nodejs端工作的时候是编译时，在浏览器端工作的时候是运行时。那我们现在先来看看经过<code>编译时</code>阶段处理后，刚刚进入到浏览器端<code>运行时</code>阶段的js代码是什么样的。我们要如何在浏览器中找到这个js文件呢？其实很简单直接在network上面找到你的那个vue文件就行了，比如我这里的文件是<code>index.vue</code>，那我只需要在network上面找叫<code>index.vue</code>的文件就行了。但是需要注意一下network上面有两个<code>index.vue</code>的js请求，分别是template模块+script模块编译后的js文件，和style模块编译后的js文件。</p><p>那怎么区分这两个<code>index.vue</code>文件呢？很简单，通过query就可以区分。由style模块编译后的js文件的URL中有type=style的query，如下图所示：</p><p><img src="`+d+`" alt="medium-zoom"></p><p>这时有的小伙伴就开始疑惑了不是说好的浏览器不认识vue文件吗？怎么这里的文件名称是<code>index.vue</code>而不是<code>index.js</code>呢？其实很简单，在开发环境时<code>index.vue</code>文件是在<code>App.vue</code>文件中import导入的，而<code>App.vue</code>文件是在<code>main.js</code>文件中import导入的。所以当浏览器中执行<code>main.js</code>的代码时发现import导入了<code>App.vue</code>文件，那浏览器就会去加载<code>App.vue</code>文件。当浏览器加载完<code>App.vue</code>文件后执行时发现import导入了<code>index.vue</code>文件，所以浏览器就会去加载<code>index.vue</code>文件，而不是<code>index.js</code>文件。</p><p>至于什么时候将<code>index.vue</code>文件中的template模块、script模块、style模块编译成js代码，我们在 <a href="https://mp.weixin.qq.com/s?__biz=MzkzMzYzNzMzMQ==&amp;mid=2247483961&amp;idx=1&amp;sn=da58c998ee2c70629603ea08d47de425&amp;scene=21#wechat_redirect" target="_blank" rel="noreferrer">通过debug搞清楚.vue文件怎么变成.js文件</a>文章中已经讲过了当import加载一个文件时会触发<code>@vitejs/plugin-vue</code>包中的<code>transform</code>钩子函数，在这个<code>transform</code>钩子函数中会将template模块、script模块、style模块编译成js代码。所以在浏览器中拿到的index.vue文件就是经过编译后的js代码了。</p><p>现在我们在浏览器的network中来看刚刚进入编译时<code>index.vue</code>文件代码，简化后的代码如下：</p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>import {</span></span>
<span class="line"><span>  Fragment as _Fragment,</span></span>
<span class="line"><span>  createElementBlock as _createElementBlock,</span></span>
<span class="line"><span>  createElementVNode as _createElementVNode,</span></span>
<span class="line"><span>  createVNode as _createVNode,</span></span>
<span class="line"><span>  defineComponent as _defineComponent,</span></span>
<span class="line"><span>  openBlock as _openBlock,</span></span>
<span class="line"><span>  toDisplayString as _toDisplayString,</span></span>
<span class="line"><span>  ref,</span></span>
<span class="line"><span>} from &quot;/node_modules/.vite/deps/vue.js?v=23bfe016&quot;;</span></span>
<span class="line"><span>import CommonChild from &quot;/src/components/vModel/child.vue?t=1710943659056&quot;;</span></span>
<span class="line"><span>import &quot;/src/components/vModel/index.vue?vue&amp;type=style&amp;index=0&amp;scoped=0ebe7d62&amp;lang.css&quot;;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>const _sfc_main = _defineComponent({</span></span>
<span class="line"><span>  __name: &quot;index&quot;,</span></span>
<span class="line"><span>  setup(__props, { expose: __expose }) {</span></span>
<span class="line"><span>    __expose();</span></span>
<span class="line"><span>    const inputValue = ref();</span></span>
<span class="line"><span>    const __returned__ = { inputValue, CommonChild };</span></span>
<span class="line"><span>    return __returned__;</span></span>
<span class="line"><span>  },</span></span>
<span class="line"><span>});</span></span>
<span class="line"><span></span></span>
<span class="line"><span>function _sfc_render(_ctx, _cache, $props, $setup, $data, $options) {</span></span>
<span class="line"><span>  return (</span></span>
<span class="line"><span>    _openBlock(),</span></span>
<span class="line"><span>    _createElementBlock(</span></span>
<span class="line"><span>      _Fragment,</span></span>
<span class="line"><span>      null,</span></span>
<span class="line"><span>      [</span></span>
<span class="line"><span>        _createVNode(</span></span>
<span class="line"><span>          $setup[&quot;CommonChild&quot;],</span></span>
<span class="line"><span>          {</span></span>
<span class="line"><span>            modelValue: $setup.inputValue,</span></span>
<span class="line"><span>            &quot;onUpdate:modelValue&quot;:</span></span>
<span class="line"><span>              _cache[0] ||</span></span>
<span class="line"><span>              (_cache[0] = ($event) =&gt; ($setup.inputValue = $event)),</span></span>
<span class="line"><span>          },</span></span>
<span class="line"><span>          null,</span></span>
<span class="line"><span>          8,</span></span>
<span class="line"><span>          [&quot;modelValue&quot;]</span></span>
<span class="line"><span>        ),</span></span>
<span class="line"><span>        _createElementVNode(</span></span>
<span class="line"><span>          &quot;p&quot;,</span></span>
<span class="line"><span>          null,</span></span>
<span class="line"><span>          &quot;input value is: &quot; + _toDisplayString($setup.inputValue),</span></span>
<span class="line"><span>          1</span></span>
<span class="line"><span>          /* TEXT */</span></span>
<span class="line"><span>        ),</span></span>
<span class="line"><span>      ],</span></span>
<span class="line"><span>      64</span></span>
<span class="line"><span>      /* STABLE_FRAGMENT */</span></span>
<span class="line"><span>    )</span></span>
<span class="line"><span>  );</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>_sfc_main.render = _sfc_render;</span></span>
<span class="line"><span>export default _sfc_main;</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br><span class="line-number">37</span><br><span class="line-number">38</span><br><span class="line-number">39</span><br><span class="line-number">40</span><br><span class="line-number">41</span><br><span class="line-number">42</span><br><span class="line-number">43</span><br><span class="line-number">44</span><br><span class="line-number">45</span><br><span class="line-number">46</span><br><span class="line-number">47</span><br><span class="line-number">48</span><br><span class="line-number">49</span><br><span class="line-number">50</span><br><span class="line-number">51</span><br><span class="line-number">52</span><br><span class="line-number">53</span><br><span class="line-number">54</span><br><span class="line-number">55</span><br><span class="line-number">56</span><br><span class="line-number">57</span><br><span class="line-number">58</span><br></div></div><p>从上面的代码中我们可以看到编译后的js代码主要分为两块，第一块是<code>_sfc_main</code>组件对象，里面有name属性和setup方法。一个vue组件在运行时实际就是一个对象，这里的<code>_sfc_main</code>就是一个vue组件对象。至于<code>defineComponent</code>函数的作用是在定义 Vue 组件时提供类型推导的辅助函数，所以在我们这个场景没什么用。我们接着来看第二块<code>_sfc_render</code>，从名字我想你应该已经猜到了他是一个render函数。执行这个<code>_sfc_render</code>函数就会生成虚拟DOM，然后再由虚拟DOM生成浏览器上面的真实DOM。</p><p>我们再来看这个<code>render</code>函数，在这个<code>render</code>函数前面会调用<code>openBlock</code>函数和<code>createElementBlock</code>函数。他的作用是在编译时尽可能的提取多的关键信息，可以减少运行时比较新旧虚拟DOM带来的性能开销，我们这篇文章不关注这点，所以我们接下来会直接看下面的<code>_createVNode</code>函数和<code>_createElementVNode</code>函数。</p><h1 id="v-model语法糖怎么工作的" tabindex="-1"><strong><code>v-model</code>语法糖怎么工作的</strong> <a class="header-anchor" href="#v-model语法糖怎么工作的" aria-label="Permalink to &quot;**\`v-model\`语法糖怎么工作的**&quot;">​</a></h1><p>我们接着来看<code>render</code>函数中的<code>_createVNode</code>函数和<code>_createElementVNode</code>函数，代码如下：</p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>import {</span></span>
<span class="line"><span>  createElementVNode as _createElementVNode,</span></span>
<span class="line"><span>  createVNode as _createVNode,</span></span>
<span class="line"><span>} from &quot;/node_modules/.vite/deps/vue.js?v=23bfe016&quot;;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>_createVNode(</span></span>
<span class="line"><span>  $setup[&quot;CommonChild&quot;],</span></span>
<span class="line"><span>  {</span></span>
<span class="line"><span>    modelValue: $setup.inputValue,</span></span>
<span class="line"><span>    &quot;onUpdate:modelValue&quot;:</span></span>
<span class="line"><span>      _cache[0] ||</span></span>
<span class="line"><span>      (_cache[0] = ($event) =&gt; ($setup.inputValue = $event)),</span></span>
<span class="line"><span>  },</span></span>
<span class="line"><span>  null,</span></span>
<span class="line"><span>  8,</span></span>
<span class="line"><span>  [&quot;modelValue&quot;]</span></span>
<span class="line"><span>),</span></span>
<span class="line"><span>_createElementVNode(</span></span>
<span class="line"><span>  &quot;p&quot;,</span></span>
<span class="line"><span>  null,</span></span>
<span class="line"><span>  &quot;input value is: &quot; + _toDisplayString($setup.inputValue),</span></span>
<span class="line"><span>  1</span></span>
<span class="line"><span>  /* TEXT */</span></span>
<span class="line"><span>),</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br></div></div><p>从这两个函数的名字我想你也能猜出来他们的作用是创建虚拟DOM，再仔细一看这两个函数不就是对应的我们template模块中的这两行代码吗。</p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>&lt;CommonChild v-model=&quot;inputValue&quot; /&gt;</span></span>
<span class="line"><span>&lt;p&gt;input value is: {{ inputValue }}&lt;/p&gt;</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>第一个<code>_createVNode</code>函数对应的是<code>CommonChild</code>，第二个<code>_createElementVNode</code>对应的是<code>p</code>标签。我们将重点放在<code>_createVNode</code>函数上，从import导入来看<code>_createVNode</code>函数是从vue中导出的<code>createVNode</code>函数。你是不是觉得<code>createVNode</code>这个名字比较熟悉呢，其实在 vue官网中有提到。</p><blockquote><p>“</p><p><code>h()</code> 是 <strong>hyperscript</strong> 的简称——意思是“能生成 HTML (超文本标记语言) 的 JavaScript”。这个名字来源于许多虚拟 DOM 实现默认形成的约定。一个更准确的名称应该是 <code>createVnode()</code>，但当你需要多次使用渲染函数时，一个简短的名字会更省力。</p></blockquote><p>vue官网中<code>h()</code> 函数用于生成虚拟DOM，其实<code>h()函数</code>底层就是调用的<code>createVnode</code>函数。同样的<code>createVnode</code>函数和<code>h()</code> 函数接收的参数也差不多，第一个参数可以是一个组件对象也可以是像<code>p</code>这样的html标签，也可以是一个虚拟DOM。第二个参数为给组件或者html标签传递的props属性或者attribute。第三个参数是该节点的children子节点。现在我们再来仔细看这个<code>_createVNode</code>函数你应该已经明白了：</p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>_createVNode(</span></span>
<span class="line"><span>  $setup[&quot;CommonChild&quot;],</span></span>
<span class="line"><span>  {</span></span>
<span class="line"><span>    modelValue: $setup.inputValue,</span></span>
<span class="line"><span>    &quot;onUpdate:modelValue&quot;:</span></span>
<span class="line"><span>      _cache[0] ||</span></span>
<span class="line"><span>      (_cache[0] = ($event) =&gt; ($setup.inputValue = $event)),</span></span>
<span class="line"><span>  },</span></span>
<span class="line"><span>  null,</span></span>
<span class="line"><span>  8,</span></span>
<span class="line"><span>  [&quot;modelValue&quot;]</span></span>
<span class="line"><span>),</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br></div></div><p>我们在 <a href="https://mp.weixin.qq.com/s?__biz=MzkzMzYzNzMzMQ==&amp;mid=2247483842&amp;idx=1&amp;sn=9d8f9ad19d8946603d681d2598f7a143&amp;scene=21#wechat_redirect" target="_blank" rel="noreferrer">Vue 3 的 setup语法糖到底是什么东西？</a>文章中已经讲过了<code>render</code>函数中的<code>$setup</code>变量就是<code>setup</code>函数的返回值经过<code>Proxy</code>处理后的对象，由于<code>Proxy</code>的拦截处理让我们在template中使用ref变量时无需再写<code>.value</code>。在上面的<code>setup</code>函数中我们看到<code>CommonChild</code>组件对象也在返回值对象中，所以这里传入给<code>createVNode</code>函数的第一个参数为<code>CommonChild</code>组件对象。</p><p>我们再来看第二个参数对象，对象中有两个key，分别是<code>modelValue</code>和<code>onUpdate:modelValue</code>。这两个key就是传递给<code>CommonChild</code>组件的两个props，等等这里有两个问题。第一个问题是这里怎么是<code>onUpdate:modelValue</code>，我们知道的<code>v-model</code>是<code>:modelValue</code>和<code>@update:modelValue</code>的语法糖，不是说好的<code>@update</code>怎么变成了<code>onUpdate</code>了呢？第二个问题是<code>onUpdate:modelValue</code>明显是事件监听而不是props属性，怎么是“通过props属性”而不是“通过事件”传递给了<code>CommonChild</code>子组件呢？</p><p>因为在编译时处理v-on事件监听会将监听的事件首字母变成大写然后在前面加一个<code>on</code>，塞到props属性对象中，所以这里才是<code>onUpdate:modelValue</code>。所以在组件上不管是v-bind的attribute和prop，还是v-on事件监听，经过编译后都会被塞到一个大的props对象中。以<code>on</code>开头的属性我们都视作事件监听，用于和普通的attribute和prop区分。所以你在组件上绑定一个<code>onConfirm</code>属性，属性值为一个<code>handleClick</code>的函数。在子组件中使用<code>emit(&#39;confirm&#39;)</code>是可以触发<code>handleClick</code>函数的执行的，但是一般情况下还是不要这样写，维护代码的人会看着一脸蒙蔽的。</p><p>我们接着来看传递给<code>CommonChild</code>组件的这两个属性值。</p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>{</span></span>
<span class="line"><span>  modelValue: $setup.inputValue,</span></span>
<span class="line"><span>  &quot;onUpdate:modelValue&quot;:</span></span>
<span class="line"><span>    _cache[0] ||</span></span>
<span class="line"><span>    (_cache[0] = ($event) =&gt; ($setup.inputValue = $event)),</span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p>第一个<code>modelValue</code>的属性值是<code>$setup.inputValue</code>。前面我们已经讲过了<code>$setup.inputValue</code>就是指向<code>setup</code>中定义的名为<code>inputValue</code>的ref变量，所以第一个属性的作用就是给<code>CommonChild</code>组件添加<code>:modelValue=&quot;inputValue&quot;</code>的属性。</p><p>我们再来看第二个属性<code>onUpdate:modelValue</code>，属性值为<code>_cache[0] ||(_cache[0] = ($event) =&gt; ($setup.inputValue = $event))</code>。这里为什么要加一个<code>_cache</code>缓存呢？原因是每次页面刷新都会重新触发<code>render</code>函数的执行，如果不加缓存那不就变成了每次执行<code>render</code>函数都会生成一个事件处理函数。这里的事件处理函数也很简单，接收一个<code>$event</code>变量然后赋值给<code>setup</code>中的<code>inputValue</code>变量。接收的<code>$event</code>变量就是我们在子组件中调用<code>emit</code>触发事件传过来的第二个变量，比如：<code>emit(&#39;update:modelValue&#39;, &#39;helllo word&#39;)</code>。为什么是第二个变量呢？是因为<code>emit</code>函数接收的第一个变量为要触发的事件名称。所以第二个属性的作用就是给<code>CommonChild</code>组件添加<code>@update:modelValue</code>的事件绑定。</p><h1 id="编译时如何处理v-model" tabindex="-1"><strong>编译时如何处理v-model</strong> <a class="header-anchor" href="#编译时如何处理v-model" aria-label="Permalink to &quot;**编译时如何处理v-model**&quot;">​</a></h1><p>前面我们已经讲过了在运行时已经拿到了key为<code>modelValue</code>和<code>onUpdate:modelValue</code>的props属性对象了，我们知道这个<code>props</code>属性对象是在编译时由<code>v-model</code>指令编译而来的，那在这个编译过程中是如何处理<code>v-model</code>指令的呢？请看下面编译时的流程图：</p><p><img src="`+l+'" alt="medium-zoom">compile-progress</p><p>首先会调用<code>parse</code>函数将template模块中的代码转换为AST抽象语法树，此时使用<code>v-model</code>的node节点的props属性中还是<code>v-model</code>。接着会调用<code>transform</code>函数，经过<code>transform</code>函数处理后在<code>node</code>节点中多了一个<code>codegenNode</code>属性。在<code>codegenNode</code>属性中我们看到没有<code>v-model</code>指令，取而代之的是<code>modelValue</code>和<code>onUpdate:modelValue</code>属性。经过<code>transform</code>函数处理后已经将<code>v-model</code>指令编译为<code>modelValue</code>和<code>onUpdate:modelValue</code>属性，此时还是AST抽象语法树。所以接下来就是调用<code>generate</code>函数将AST抽象语法树转换为<code>render</code>函数，到此为止编译时做的事情已经做完了。</p><h2 id="parse函数" tabindex="-1"><strong><code>parse</code>函数</strong> <a class="header-anchor" href="#parse函数" aria-label="Permalink to &quot;**`parse`函数**&quot;">​</a></h2><p>首先是使用<code>parse</code>函数将template模块中的代码编译成AST抽象语法树，在这个过程中会使用到大量的正则表达式对字符串进行解析。我们直接来看编译后的AST抽象语法树是什么样子：</p><p><img src="'+r+'" alt="medium-zoom"></p><p>从上图中我们可以看到使用<code>v-model</code>指令的node节点中有了<code>name</code>为<code>model</code>和<code>rawName</code>为<code>v-model</code>的props了，明显可以看出将template中code代码字符串转换为AST抽象语法树时没有处理<code>v-model</code>指令。那么什么时候处理的<code>v-model</code>指令呢？</p><h2 id="transform函数" tabindex="-1"><strong><code>transform</code>函数</strong> <a class="header-anchor" href="#transform函数" aria-label="Permalink to &quot;**`transform`函数**&quot;">​</a></h2><p>其实是在后面的一个<code>transform</code>函数中处理的，在这个函数中主要调用的是<code>traverseNode</code>函数处理AST抽象语法树。在<code>traverseNode</code>函数中会去递归的去处理AST抽象语法树中的所有node节点，这也解释了为什么还要在<code>transform</code>函数中再抽取出来一个<code>traverseNode</code>函数。</p><p>我们再来思考一个问题，由于<code>traverseNode</code>函数会处理node节点的所有情况，比如<code>v-model</code>指令、<code>v-for</code>指令、<code>v-on</code>、<code>v-bind</code>。如果将这些的逻辑全部都放到<code>traverseNode</code>函数中，那<code>traverseNode</code>函数的体量将会是非常大的。所以抽取出来一个<code>nodeTransforms</code>的概念，这个<code>nodeTransforms</code>是一个数组。里面存了一组<code>transform</code>函数，用于处理node节点。每个<code>transform</code>函数都有自己独有的作用，比如<code>transformModel</code>函数用于处理<code>v-model</code>指令，<code>transformIf</code>函数用于处理<code>v-if</code>指令。我们来看看经过<code>transform</code>函数处理后的AST抽象语法树是什么样的：</p><p><img src="'+t+'" alt="medium-zoom"></p><p>从上图中我们可以看到同一个使用<code>v-model</code>指令的node节点，经过<code>transform</code>函数处理后的和第一步经过<code>parse</code>函数处理后比起来node节点最外层多了一个<code>codegenNode</code>属性。</p><p>我们接下来看看<code>codegenNode</code>属性里面是什么样的：</p><p><img src="'+i+'" alt="medium-zoom"></p><p>从上图中我们可以看到在<code>codegenNode</code>中还有一个<code>props</code>属性，在<code>props</code>属性下面还有一个<code>properties</code>属性。这个<code>properties</code>属性是一个数组，里面就是存的是node节点经过transform函数处理后的props属性的内容。我们看到<code>properties</code>数组中的每一个item都有<code>key</code>和<code>value</code>属性，我想你应该已经反应过来了，这个<code>key</code>和<code>value</code>分别对应的是props属性中的属性名和属性值。从上图中我们看到第一个属性的属性名<code>key</code>的值为<code>modelValue</code>，属性值<code>value</code>为<code>$setup.inputValue</code>。这个刚好就对应上<code>v-model</code>指令编译后的<code>:modelValue=&quot;$setup.inputValue&quot;</code>。</p><p>我们再来接着看第二个属性：</p><p><img src="'+u+'" alt="medium-zoom"></p><p>从上图中我们同样也可以看到第二个属性的属性名<code>key</code>的值为<code>onUpdate:modelValue</code>，属性值<code>value</code>的值拼起来就是为一串箭头函数，和我们前面编译后的代码一模一样。第二个属性刚好就对应上<code>v-model</code>指令编译后的<code>@update:modelValue=&quot;($event) =&gt; ($setup.inputValue = $event)&quot;</code>。</p><p>从上面的分析我们看到经过<code>transform</code>函数的处理后已经将<code>v-model</code>指令处理为对应的代码了，接下来我们要做的事情就是调用<code>generate</code>函数将AST抽象语法树转换成<code>render</code>函数</p><h2 id="generate函数" tabindex="-1"><strong><code>generate</code>函数</strong> <a class="header-anchor" href="#generate函数" aria-label="Permalink to &quot;**`generate`函数**&quot;">​</a></h2><p>在<code>generate</code>函数中会递归遍历AST抽象语法树，然后生成对应的浏览器可执行的js代码。如下图：</p><p><img src="'+m+'" alt="medium-zoom"></p><p>从上图中我们可以看到经过<code>generate</code>函数处理后生成的<code>render</code>函数和我们之前在浏览器的network中看到的经过编译后的<code>index.vue</code>文件中的<code>render</code>函数一模一样。这也证明了<code>modelValue</code>属性和<code>@update:modelValue</code>事件塞到组件上是在编译时进行的。</p><h1 id="总结" tabindex="-1"><strong>总结</strong> <a class="header-anchor" href="#总结" aria-label="Permalink to &quot;**总结**&quot;">​</a></h1><p>现在我们可以回答前面提的两个问题了：</p><ul><li><p><code>v-model</code>指令是如何变成组件上的<code>modelValue</code>属性和<code>@update:modelValue</code>事件呢？</p><p>首先会调用<code>parse</code>函数将template模块中的代码转换为AST抽象语法树，此时使用<code>v-model</code>的node节点的props属性中还是<code>v-model</code>。接着会调用<code>transform</code>函数，经过<code>transform</code>函数处理后在<code>node</code>节点中多了一个<code>codegenNode</code>属性。在<code>codegenNode</code>属性中我们看到没有<code>v-model</code>指令，取而代之的是<code>modelValue</code>和<code>onUpdate:modelValue</code>属性。经过<code>transform</code>函数处理后已经将<code>v-model</code>指令编译为<code>modelValue</code>和<code>onUpdate:modelValue</code>属性。其实在运行时<code>onUpdate:modelValue</code>属性就是等同于<code>@update:modelValue</code>事件。接着就是调用<code>generate</code>函数，将AST抽象语法树生成<code>render</code>函数。然后在浏览器中执行<code>render</code>函数时，将拿到的<code>modelValue</code>和<code>onUpdate:modelValue</code>属性塞到组件对象上，所以在组件上就多了两个<code>modelValue</code>属性和<code>@update:modelValue</code>事件。</p></li><li><p>将<code>v-model</code>指令转换为<code>modelValue</code>属性和<code>@update:modelValue</code>事件这一过程是在编译时还是运行时进行的呢？</p><p>从上面的问题答案中我们可以知道将<code>v-model</code>指令转换为<code>modelValue</code>属性和<code>@update:modelValue</code>事件这一过程是在编译时进行的。</p></li></ul><p>在<code>transform</code>函数中是调用<code>transformModel</code>函数处理<code>v-model</code>指令，这篇文章没有深入到<code>transformModel</code>函数源码内去讲解。如果大家对<code>transformModel</code>函数的源码感兴趣请在评论区留言或者给我发信息，我会在后面的文章安排上。</p>',71),h=[v];function g(_,V,f,q,x,k){return s(),n("div",null,h)}const $=e(b,[["render",g]]);export{N as __pageData,$ as default};
